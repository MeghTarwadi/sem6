# Question 1

### S22

#### (a)What is meant by Software and Software Engineering? 03

**Software:**
(Refer to Chapter 1, Section 1.1, Page 1-2)
Software is nothing but a collection of computer programs and related documents that are intended to provide desired features, functionalities and better performance.
Software products may be:

1. Generic - That means developed to be sold to a range of different customers.
2. Custom - That means developed for a single customer according to their specification.

**Software Engineering:**
(Refer to Chapter 1, Section 1.3, Page 1-3)
"Software engineering is a discipline in which theories, methods and tools are applied to develop professional software."
"In software engineering a systematic and organized approach is adopted."
(Refer to Chapter 1, Section 1.4, Page 1-4, Role of Software Engineer)
"The software engineer has to adopt systematic and organized approach in order to produce high quality software. He is also responsible for selecting the most appropriate method for software development."

#### (b)Discuss merits and demerits of Waterfall model. 04

The Waterfall model, also known as the Linear Sequential Model, has the following phases:
(Refer to Chapter 1, Subsection 1.10.1, Page 1-13, Fig. 1.10.2 Waterfall model)

1. Requirement gathering and analysis
2. Design
3. Coding
4. Testing
5. Maintenance

**Merits (Benefits) of waterfall model:**
(Refer to Chapter 1, Subsection 1.10.1, Page 1-14)

1. The waterfall model is simple to implement.
2. For implementation of small systems waterfall model is useful.

**Demerits (Drawbacks) of waterfall model:**
(Refer to Chapter 1, Subsection 1.10.1, Page 1-14)

1. It is difficult to follow the sequential flow in software development process. If some changes are made at some phases then it may cause some confusion.
2. The requirement analysis is done initially and sometimes it is not possible to state all the requirements explicitly in the beginning. This causes difficulty in the project.
3. The customer can see the working model of the project only at the end. After reviewing of the working model; if the customer gets dissatisfied then it causes serious problems.
4. Linear nature of waterfall model induces blocking states, because certain tasks may be dependant on some previous tasks. Hence it is necessary to accomplish all the dependant tasks first. It may cause long waiting time.

#### (c)What is the importance of Process Model in development of Software System? Discuss Spiral Model in detail. 07

**Importance of Process Model:**
(Refer to Chapter 1, Section 1.10, Page 1-12)
The process model can be defined as the abstract representation of process. The appropriate process model can be chosen based on abstract representation of process. The software process model is also known as Software Development Life Cycle (SDLC) Model or software paradigm. These models are called prescriptive process models because they are following some rules for correct usage. In this model various activities are carried out in some specific sequence to make the desired software product. It helps in discussing various process models one by one.

**Spiral Model in detail:**
(Refer to Chapter 1, Subsection 1.10.2.2, Pages 1-17 to 1-19)
This model possess the iterative nature of prototyping model and controlled and systematic approaches of the linear sequential model. This model gives efficient development of incremental versions of software. In this model, the software is developed in series of increments. The sprial model is divided into a number of framework activities. These framework activities are denoted by task regions. Usually there are six tasks regions. (Refer to Fig. 1.10.4 Spiral model on Page 1-18).
The task regions can be described as :
(Refer to Page 1-19)
i) **Customer communication** - In this region, it is suggested to establish customer communication.
ii) **Planning** - All planning activities are carried out in order to define resources, time line and other project related activities.
iii) **Risk analysis** - The tasks required to calculate technical and management risks are carried out.
iv) **Engineering** - In this task region, tasks required to build one or more representations of applications are carried out.
v) **Construct and release** - All the necessary tasks required to construct, test, install the application are conducted. Some tasks that are required to provide user support are also carried out in this task region.
vi) **Customer evaluation** - Customer's feedback is obtained and based on customer evaluation required tasks are performed and implemented at installation stage.

**Advantages of spiral model (implied):**
(Refer to Page 1-18)
Spiral model is realistic approach to development of large-scale systems and software. Because customer and developer better understand the problem statement at each evolutionary level. Also risks can be identified or rectified at each such level. During planning phase, the cost and schedule of software can be planned and adjusted based on feedback obtained from customer evaluation.

**Drawbacks of spiral model:**
(Refer to Chapter 1, Subsection 1.10.2.2, Page 1-19)

- It is based on customer communication. If the communication is not proper then the software product that gets developed will not be up to the mark.
- It demands considerable risk assessment. If the risk assessment is done properly then only the successful product can be obtained.

**When to choose Spiral Model?:**
(Refer to Chapter 1, Subsection 1.10.2.2, Page 1-19)

1. When the prototypes for the software functionality are needed.
2. When requirements are not very clearly defined or complex.
3. When the large or high budget projects need to be developed.
4. When the risk assessment is very critical and essential.
5. When project is not expected within a specific limited time span.

---

### S23

#### (a)What is Software Engineering? Justify Software is Engineered but not Manufactured 03 (RE)

**What is Software Engineering?:**
(Refer to Chapter 1, Section 1.3, Page 1-3)
"Software engineering is a discipline in which theories, methods and tools are applied to develop professional software."

**Justify Software is Engineered but not Manufactured:**
(Refer to Chapter 1, Section 1.4, Page 1-4)
"Software is engineered, not manufactured". "Software development and hardware development are two different activities. A good design is a backbone for both the activities. Quality problems that occur in hardware manufacturing phase can not be removed easily. On the other hand, during software development process such problems can be rectified."
(Refer to Chapter 1, Section 1.5, Page 1-5, Comparison table)
Under Hardware product characteristics: "Hardware products are manufactured."
Under Software product characteristics: "Software is engineered and not manufactured."

#### (b)What is Process? Discuss the process framework activities. 04

**What is Process?:**
(Refer to Chapter 1, Section 1.10, Page 1-12)
"The process model can be defined as the abstract representation of process."
(Refer to Chapter 1, Section 1.8.1, Page 1-11, Review Question 3 discussion)
"A software process model is an abstract representation of a process. It presents a description of a process from some particular perspective."

**Process framework activities:**
(Refer to Chapter 1, Section 1.8.1, Page 1-11, referring to Fig 1.8.1 on Page 1-10)
The software process is characterized by process framework activities. Process framework activities are:

1. Communication
2. Planning
3. Modeling
   - Analysis of requirements
   - Design
4. Construction
   - Code generation
   - Testing
5. Deployment

#### (c)Explain Spiral Process Model and states its advantages and disadvantages. 07 (RE)

(Refer to Answer for S22 Q1 (c))

---

### S24

#### (a)Describe software engineering as a layered technology. 03

(Refer to Chapter 1, Section 1.7, Pages 1-8 to 1-9)
"Software engineering is a layered technology. Software can be developed using these layered approaches. Various layers on which the technology is based are quality focus layer, process layer, methods layer, tools layer." (Refer to Fig. 1.7.1 Software engineering : A layered approach on Page 1-8).

- **A quality focus layer:** A disciplined quality management is a backbone of software engineering technology.
- **Process layer:** "Process layer is a foundation of software engineering. Basically, process defines the framework for timely delivery of software."
- **Methods layer:** "In method layer the actual method of implementation is carried out with the help of requirement analysis, designing, coding using desired programming constructs and testing."
- **Tools layer:** "Software tools are used to bring automation in software development process."
  "Thus software engineering is a combination of process, methods, and tools for development of quality software."

#### (b)Describe various umbrella activities in software development. 04

(Refer to Chapter 1, Section 1.11, Page 1-11)
"The umbrella activities occur throughout the process. They focus on project management, tracking and control. The umbrella activities are:

1. **Software project tracking and control** - This is an activity in which software team can assess progress and take corrective action to maintain schedule.
2. **Risk management** - The risks that may affect project outcomes or quality can be analyzed.
3. **Software quality assurance** - These are activities required to maintain software quality.
4. **Formal technical reviews** - It is required to assess engineering work products to uncover and remove errors before they propagate to next activity.
5. **Software configuration management** - Managing of configuration process when any change in the software occurs.
6. **Work product preparation and production** - The activities to create models, documents, logs, forms and lists are carried out.
7. **Reusability management** - It defines criteria for work product reuse.
8. **Measurement** - In this activity, the process can be defined and collected. Also project and product measures are used to assist the software team in delivering the required software."

#### (c)Discuss spiral model with diagram and compare it with waterfall model. 07

(For Spiral Model discussion and diagram, refer to Answer for S22 Q1 (c))

**Comparison of Spiral Model with Waterfall Model:**
(Synthesized from descriptions in Chapter 1, Sections 1.10.1 and 1.10.2.2)

| Feature                            | Spiral Model                                                                                                                  | Waterfall Model                                                                          |
| :--------------------------------- | :---------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------- |
| **Approach**                 | Iterative and risk-driven, series of increments. (Page 1-17)                                                                  | Linear sequential. (Page 1-12)                                                           |
| **Risk Management**          | Explicit risk assessment in each cycle. (Page 1-18, 1-19 "Risk analysis" task region, "demands considerable risk assessment") | Implicit, risks not explicitly handled phase-wise.                                       |
| **Customer Involvement**     | High, feedback obtained in each cycle ("Customer evaluation" task region). (Page 1-19)                                        | Limited, mainly at the start (requirements) and end (delivery). (Page 1-14 Drawback 3)   |
| **Flexibility to Changes**   | Accommodates changes well due to iterative nature.                                                                            | Difficult to accommodate changes once a phase is complete. (Page 1-14 Drawback 1)        |
| **Prototyping**              | Prototypes developed in early cycles if needed ("prototype gets developed"). (Page 1-18)                                      | Not an inherent part.                                                                    |
| **Project Size Suitability** | Suitable for large, complex, high-risk projects. (Page 1-19 "When to choose it?")                                             | Suitable for small systems where requirements are well understood. (Page 1-14 Benefit 2) |
| **Complexity**               | More complex to manage due to iterations and risk analysis.                                                                   | Simple to understand and implement. (Page 1-14 Benefit 1)                                |
| **Documentation**            | Can be extensive due to multiple iterations and risk documentation.                                                           | Documentation is created phase-wise.                                                     |
| **Early Working Model**      | Incremental versions of software are produced. (Page 1-17)                                                                    | Working model only available at the end. (Page 1-14 Drawback 3)                          |

---

### W24

#### (a)Why Spiral Process Model is also known as Meta Model? 03

The provided textbook pages (Chapter 1, Section 1.10.2.2, Pages 1-17 to 1-19) do not explicitly state that the Spiral Process Model is also known as a "Meta Model," nor do they provide a direct justification for such a naming. However, the characteristics of the Spiral Model suggest why it might be considered in such a way by some:
It possesses an iterative nature and is risk-driven. (Page 1-17: "This model possess the iterative nature of prototyping model and controlled and systematic approaches of the linear sequential model.")
It is divided into a number of framework activities denoted by task regions, which are repeated in iterations. (Page 1-17: "The sprial model is divided into a number of framework activities. These framework activities are denoted by task regions.") (Page 1-19: "Customer communication", "Planning", "Risk analysis", "Engineering", "Construct and release", "Customer evaluation").
Its structure allows for the incorporation of other process approaches (like prototyping or aspects of sequential development) within its iterations, depending on the project's needs and risk assessment. (Page 1-18: "In the initial pass, product specification is built and in subsequent passes around the spiral the prototype gets developed and then more improved versions of software gets developed.")
This flexibility and its encompassing framework for managing development through iterative, risk-managed cycles give it characteristics that align with the concept of a meta-model (a model for creating models or a high-level process framework).

#### (b)Compare Prototype Process Model with RAD Process Model. 04

(Synthesized from Chapter 1, Section 1.10.2.1 Prototype Model pp. 1-16 to 1-17 and Section 1.10.3.1 RAD Model pp. 1-21 to 1-22)

| Feature                                | Prototype Process Model                                                                                                                   | RAD Process Model                                                                                                                |
| :------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------- |
| **Primary Goal**                 | To clarify software requirements and get early user feedback when requirements are uncertain. (Page 1-16)                                 | To achieve extremely short development cycle for a fully functional system. (Page 1-21)                                          |
| **Requirements Understanding**   | Used when requirements are not well understood initially. (Page 1-16 "In prototyping model initially the requirement gathering is done.") | Best suited when requirements are fully understood and well-defined. (Page 1-21 "When the requirements are fully understood...") |
| **Development Speed**            | Focus is on quick development of a prototype, overall project speed varies.                                                               | Aims for very rapid development (e.g., 60-90 days for the full system). (Page 1-21)                                              |
| **End Product of Initial Cycle** | A working prototype, which may be refined, partially used, or discarded. (Page 1-16)                                                      | A functional system or significant increment.                                                                                    |
| **User Involvement**             | High and continuous for evaluating the prototype and providing feedback. (Page 1-16)                                                      | Primarily intensive during requirements gathering (JAD sessions) and user review of increments. (Page 1-21)                      |
| **Team Structure**               | Can be managed by smaller teams.                                                                                                          | Often involves multiple teams working in parallel on components. (Page 1-21 "Multiple teams work...")                            |
| **Tool Usage**                   | May use rapid prototyping tools.                                                                                                          | Heavily relies on powerful development tools, component-based construction, and code generators. (Page 1-21)                     |
| **Risk Addressed**               | Primarily addresses risk of incorrect or incomplete requirements.                                                                         | Addresses risk of long development times; less suited for high technical risk. (Page 1-22 Example 1.10.7)                        |
| **Throwaway Aspect**             | Prototype is often intended to be thrown away or significantly reworked. (Page 1-16 "throw away the prototype")                           | Builds are intended to be part of the final system.                                                                              |

#### (c)Explain the working of Incremental Process Model with suitable diagram. 07

(Refer to Chapter 1, Section 1.10.3, Page 1-20 and Fig. 1.10.1 on Page 1-12 which shows "Incremental process model" as a category)
"In this model with limited functionality the basic software product is created for user's understanding. This model is refined and expanded in later phases."
The Incremental Process Model combines elements of linear sequential models (applied iteratively) and the iterative philosophy of prototyping. The product is designed, implemented, and tested as a series of incremental builds. Each increment adds more functionality.

**Working:**

1. The overall requirements are divided into various builds or increments.
2. The first increment is typically a core product with basic requirements implemented.
3. This core product is delivered to the customer, or undergoes detailed evaluation.
4. Subsequent increments build upon the previously delivered ones, adding new features and functionality.
5. The process is repeated, with each increment going through requirement analysis, design, coding, and testing.
6. This continues until the complete product is developed. Each increment delivers an operational product.

(The textbook on page 1-20 does not provide a specific diagram for the general Incremental Process Model. Fig. 1.10.1 on page 1-12 categorizes it. A conceptual diagram would show a series of mini-waterfalls or iterations, each producing an increment. The user's initial answer provides a suitable generic diagram for this concept.)
A conceptual diagram would typically show:

- Initial Planning/Requirements for the whole system.
- A loop or sequence of:
  - Increment 1: Analysis -> Design -> Code -> Test -> Deliver/Integrate
  - Increment 2: Analysis -> Design -> Code -> Test -> Deliver/Integrate
  - ...
  - Increment n: Analysis -> Design -> Code -> Test -> Deliver/Integrate
- Resulting in the final system.

This model allows for early delivery of functional parts of the software and easier incorporation of changes as development progresses.

---

# Question 2

### S22

#### (a)Define agile process .Give any two agile principles. 03

**Define agile process:**
(Refer to Chapter 2, Section 2.1, Page 2-2)
"In 1980's the heavy weight, plan based software development approach was used to develop any software product... Hence new methods were proposed in 1990's which are known as agile processes."
"The agile processes are the light-weight methods are people-based rather than plan-based methods. The agile process forces the development team to focus on software itself rather than design and documentation. The agile process believes in iterative method. The aim of agile process is to deliver the working model of software quickly to the customer."

**Any two agile principles:**
(Refer to Chapter 2, Section 2.1.1, Page 2-3)

1. Satisfy the customer by early and continuous delivery of valuable software.
2. The changes in the requirements must be accommodated. Even though the changes occur late in the software development process, the agile process should help to accommodate them.
   (Any two from the list of 12 can be chosen)

#### (b)Describe FOUR Ps for Project Management. 04

(The "Four Ps" of Project Management - People, Product, Process, Project - are a standard concept. While Chapter 3 is on Managing Software Project, the OCR'd TOC does not show a dedicated section for the "Four Ps". This information is foundational and might be assumed or covered generally. Based on the user's initial correct structure, I will provide a standard SE description, which is generally aligned with typical textbook coverage of this topic.)

The Four Ps for Project Management provide a framework for considering the key aspects of any software project:

1. **People:** This refers to all stakeholders involved in the project, including the project team (developers, testers, managers), customers, and end-users. Effective management of people involves clear communication, defined roles and responsibilities, motivation, and skill development. The project manager must build a cohesive and effective team.
2. **Product:** This is the software to be built. It is crucial to have a clear scope and objectives for the product. The requirements for the product must be well-defined, and all stakeholders should have a common understanding of what is to be delivered.
3. **Process:** This refers to the framework of tasks or activities that need to be performed to develop the software product. A well-defined process provides a roadmap for the project team, outlining how the software will be engineered and managed from conception to deployment.
4. **Project:** This involves all the work required to make the product a reality. Project management activities include planning, organizing, monitoring, and controlling all aspects of the project, such as scope, schedule, budget, and resources, to achieve the project objectives.

#### (c)Explain Scrum with its advantages and disadvantages. 07

(Refer to Chapter 2, Section 2.3.3, Pages 2-11 to 2-12)
"SCRUM is an agile process model which is used for developing the complex software systems."
"It is a lightweight process framework that can be used to manage and control the software development using iterative and incremental approach."

**Scrum Process Activities:**
(Refer to Page 2-11)

1. **Backlog:** "It is basically a list of project requirements or features that must be provided to the customer. The items can be included in the backlog list at any time. The product manager analyses this list and updates the priorities as per the requirements." (Product backlog and Sprint backlog as per Fig. 2.3.2 on Page 2-12)
2. **Sprint:** "These are the work units that are needed to achieve the requirements mentioned in the backlogs. Typically the sprints have fixed duration or time-box (typically of 2 to 4 weeks). Thus sprints allow the team members to work in stable and short-term environment."
3. **Meetings:** (Refer to Page 2-12) "These are 15 minutes daily meetings to report the completed activities, obstacles and plan for next activities." (Often called Daily Scrum or Stand-up).
4. **Demo:** (Refer to Page 2-12) "During this phase, the software increment is delivered to the customer. The implemented functionality which is demonstrated to the customer." (Often called Sprint Review).

**Roles:**
(Refer to Page 2-12)

1. **Scrum Master:** "The Scrum master leads the meeting and analyses the response of each team member. The potential problems are discussed and solved in the meeting with the help of master."
2. **Team Members:** "These are the persons working in a team to develop the software solutions." (Often referred to as the Development Team). (The Product Owner is also a key role, responsible for the backlog, though not explicitly detailed under "Roles" on this page, it's implied with "product manager" for backlog).

**Advantages:**
(Refer to Page 2-12)

1. SCRUM model brings transparency in project development status.
2. It provides flexibility towards the changes.
3. There is improved communication, minimum overhead in development process.
4. The productivity can be improved.

**Disadvantages:**
(Refer to Chapter 2, Section 2.3.4 (FDD, but applies to Scrum too), Page 2-13 for general agile disadvantages, or typical Scrum challenges)
(Page 2-13 under FDD, but general enough: "Some decisions are hard to track in fixed time span." "There are problems to deal with non-functional requirements of the system.")
Specific disadvantages typically associated with Scrum (though not explicitly listed on these pages):

- Requires experienced and self-organizing teams.
- Scope creep can be an issue if the Product Owner doesn't manage the backlog well.
- Can be challenging to implement in large, distributed organizations without modifications.

#### OR(c) Explain Extreme Programming (XP) in detail. 07

(Refer to Chapter 2, Section 2.2, Pages 2-4 to 2-8)
"Extreme Programming (XP) is one of the best known agile process. It is suggested by Kent Beck in 2000."

**XP Values:**
(Refer to Section 2.2.1, Page 2-4 to 2-5)

1. **Communication:** "The effective communication must be established between software developers and stakeholders..."
2. **Simplicity:** "XP focuses on the current needs instead of futures needs... Software design should be simple."
3. **Feedback:** "The feedback for the software product can be obtained from the developers of the software, customers, and other software team members."
4. **Courage:** "The strict adherence to certain XP practices require courage. The agile XP team must be disciplined to design the system today, recognize the future requirements and make the changes dramatically as per the demand."
5. **Respect:** "By following the above states XP values the agile team can win the respect of stakeholders."

**XP Process:**
(Refer to Section 2.2.2, Page 2-5, Fig. 2.2.1 XP process)

- "Customer specifies and priorities the system requirements. Customer becomes one of the important members of development team. The developer and customer together prepare a **story-card** in which customer needs are mentioned."
- "The developer team then aims to implement the scenarios in the story-card."
- "After developing the story-card the development team breaks down the total work in **small tasks**."
- "The customer priorities the stories for implementation... release the complete software in **small and frequent releases**."
- "For accommodating new changes, new story-card must be developed."
- "Evaluate, the system along with the customer."
  The process involves Planning, Design, Coding, and Testing in short iterative cycles, with refactoring. (Refer to Fig. 2.2.1)

**XP Practices (Rules and Practices):**
(Refer to table on Page 2-6)

- **Planning:** User story-cards, Release planning, Small releases, Iterative process, Stand up meetings.
- **Designing:** Simple design, Spike solution, Refactoring.
- **Coding:** Customer availability, Paired programming, Collective code ownership.
- **Testing:** Unit testing (test-first development), Continuous integration. (Refer to Page 2-7 for Unit testing and Continuous integration description in XP context)

**Industrial XP (IXP):**
(Refer to Section 2.2.3, Page 2-7)
"The industrial XP (IXP) can be defined as the organic evolution of XP. It is customer centric. It has expanded role for customers and advanced technical practices."
(Page 2-8 describes further aspects of IXP like Readiness Assessment, Project Community, Project Chartering, Test Driven management, Retrospectives, Continuous learning).

---

### S23

#### (a)Discuss the differences among Reactive and Proactive Risks. 03

(Refer to Chapter 3, Section 3.7.2, Page 3-33)
**Reactive risk strategies:**
"Reactive risk strategies means monitor the project for likely risks. Resources are set aside to deal with them, should they become actual problems. More commonly, the software team does nothing about risks until something goes wrong. Then the team flies into action in an attempt to correct the problem rapidly. This is often called a firefighting approach. When this fails, crisis management takes over."

**Proactive risk strategies:**
"Proactive risk strategies means the risks are identified, their probability and impact are assessed and they are ranked by importance. Then the software team establishes a plan for managing risk. The primary objective is to avoid risk... A proactive strategy for risk management is to develop contingency plans."

**Differences (summarized from text):**

- **Timing:** Reactive strategies address risks after they occur ("until something goes wrong"). Proactive strategies address risks before they become major problems ("begins long before technical work is initiated").
- **Approach:** Reactive is "firefighting" or crisis management. Proactive involves planning, assessment, and contingency plans to avoid or mitigate risks.
- **Planning:** Reactive involves minimal prior planning for specific risks beyond setting some resources aside. Proactive involves detailed risk assessment and management planning.

#### (b)Explain the process model which is defined as the ability of a project team to respond rapidly to a change. 04

This description refers to **Agile Process Models**.
(Refer to Chapter 2, Section 2.1, Page 2-2)
"The agile process believes in iterative method. The aim of agile process is to deliver the working model of software quickly to the customer."
"It is easy to accommodate changes during the requirement gathering stage." (Conventional method disadvantage, implying agile handles it better).
(Refer to Chapter 2, Section 2.1.1, Page 2-3, Agility Principle 2)
"The changes in the requirements must be accommodated. Even though the changes occur late in the software development process, the agile process should help to accommodate them."
Agile methodologies are designed to embrace change. Examples include Scrum, XP, etc., which emphasize iterative development, frequent feedback, and adaptive planning, allowing teams to respond rapidly to changing requirements.

#### (c)Explain Project Scheduling Process. Also Explain Gantt Chart in detail. 07

**Project Scheduling Process:**
(Refer to Chapter 3, Section 3.6.1, Page 3-27, Fig. 3.6.1 Project scheduling process)
"While scheduling the project, the manager has to estimate the time and resource of the project. All the activities in the project must be arranged in coherent sequence. The schedules must be continually updated because some uncertain problems may occur during the project life cycle. For new projects initial estimates can be made optimistically."
"During the project scheduling the total work is separated into various small activities. And time required for each activity must be determined by the project manager. For efficient performance some activities are conducted in parallel."
The process involves:

1. Identify activities
2. Identify possible dependencies
3. Estimate resources
4. Assign people to conduct activities
5. Create activity network and bar charts

"The project manager should be aware of the fact that : Every stage of the project may not be problem-free. Some of the typical problems in project development stage are : People may leave or remain absent. Hardware may get failed. Software resource may not be available."

**Gantt Chart in detail:**
(Refer to Chapter 3, Section 3.6.4, Page 3-29 to 3-30, Fig. 3.6.3 Time Line chart)
"In software project scheduling the timeline chart is created. The purpose of timeline chart is to emphasize the scope of individual task. Hence set of tasks are given as input to the time line chart."
"The time line chart is also called as Gantt chart."
"The time line chart can be developed for entire project or it can be developed for individual functions."
Characteristics of a Gantt Chart (from general understanding and Fig 3.6.3):

1. All tasks are listed at the leftmost column.
2. The horizontal bars indicate the time required by the corresponding task.
3. When multiple horizontal bars occur at the same time on the calendar, then it means concurrency can be applied for performing the tasks.
4. The diamonds indicate the milestones.
5. In most of the projects, after generation the time line chart the project tables are prepared. In project tables all the tasks are listed along with actual start and end dates and related information.
   (Fig. 3.6.3 on Page 3-30 shows an example of a Gantt Chart.)

#### OR(c) Explain COCOMO model for cost estimation. 07

(The provided OCR'd pages for Chapter 3 on Software Project Estimations, Section 3.4, Pages 3-17 onwards, focus on LOC-based, FP-based, process-based, and use-case based estimations. A detailed explanation of the COCOMO model itself - Basic, Intermediate, or Detailed - is not explicitly found in these specific OCR'd pages. The textbook mentions COCOMO model in the syllabus, but these pages don't elaborate on it.)

If this question must be answered using _only_ the provided pages, one would state that while cost estimation is discussed, the specific details of the COCOMO model are not present in the provided text excerpts covering LOC, FP, Process, and Use-Case estimation methods. A general discussion on estimation principles from Section 3.4 could be provided, but it wouldn't be specific to COCOMO.

---

### S24

#### (a)What are the characteristics of the software? 03

(Refer to Chapter 1, Section 1.4, Page 1-4)
"Software development is a logical activity and therefore it is important to understand basic characteristics of software. Some important characteristics of software are :

- **Software is engineered, not manufactured:** Software development and hardware development are two different activities. Quality problems that occur in hardware manufacturing phase can not be removed easily. On the other hand, during software development process such problems can be rectified.
- **Software does not ware out:** In early stage of hardware development process the failure rate is very high because of manufacturing defects. But after correcting such defects the failure rate gets reduced. The failure rate remains constant for some period of time and again it starts increasing because of environmental maladies (extreme temperature, dusts, and vibrations). On the other hand software does not get affected from such environmental maladies. Hence ideally it should have an "idealized curve". But due to some undiscovered errors the failure rate is high and drops down as soon as the errors get corrected. (Refer to Fig. 1.4.1 Failure curves for hardware and software on Page 1-4)
- **Most software is custom built rather than being assembled from components:** While developing any hardware product firstly the circuit design with desired functioning properties is created. Then required hardware components such as ICs, capacitors and registers are assembled according to the design, but this is not done while developing software product. Most of the software is custom built." (Page 1-5)
  (Additional characteristics often cited include complexity, changeability, invisibility, conformity.)

#### (b)Explain Gantt chart in detail. 04

(RE) See S23 Q2 (c).
(Refer to Chapter 3, Section 3.6.4, Page 3-29 to 3-30, Fig. 3.6.3 Time Line chart)

#### (c)List different agile process models and describe any one model in detail. 07

(Refer to Chapter 2, Section 2.3, Page 2-8 onwards)
"Various other agile process models apart from extreme programming are:

1. Adaptive Software Development
2. Dynamic System Development Method
3. Scrum
4. Feature Driven Development
5. Agile Modeling"

**Description of one model in detail (e.g., Adaptive Software Development - ASD):**
(Refer to Chapter 2, Section 2.3.1, Pages 2-9 to 2-10, Fig. 2.3.1 Adaptive software development life cycle)
"The adaptive software development approach was proposed by Jim Highsmith. This approach is useful in building the complex software systems using iterative approach."
"The focus of this method is on working in collaboration and team self organization."
"The life cycle of ASD consists of three phases of software development and those are - 1. Speculation 2. Collaboration 3. Learning. (Refer Fig. 2.3.1)"

1. **Speculation:** "This is an initial phase of the adaptive software development process. In this phase the adaptive cycle planning is conducted. In this cycle planning mainly three types of information is used such as - Customer's mission statement, project constraints (delivery date, user description, budgets and so on) and basic requirements of the project."
2. **Collaboration:** "The motivated people work in collaboration to develop the desired software product. In this phase collaboration among the members of development team is a key factor. For successful collaboration and coordination it is necessary to have following qualities in every individual - Assist each other without resentment, Work hard, Posses the required skill set, Communicate problems and help each other to accomplish the given task, Criticize without any hate."
3. **Learning:** "As the team members go on developing the components, the emphasize is on learning new skills and techniques. There are three ways by which the team members learn - Focus groups, Formal technical review, Postmortems."

#### OR(c) What are the principles of agile model? Also explain its advantages and disadvantages.07

**Principles of agile model:**
(RE) See S22 Q2 (a).
(Refer to Chapter 2, Section 2.1.1, Page 2-3. List any number as required, typically 12 are famous.)
e.g.,

1. Satisfy the customer by early and continuous delivery of valuable software.
2. The changes in the requirements must be accommodated.
3. Deliver working software quite often.
4. Business people and developers must work together throughput the project.
5. Motivate the people who are building the projects.
   (And so on, up to 12 principles listed on Page 2-3 and 2-4)

**Advantages of agile model (General):**
(Synthesized from Chapter 2, Section 2.1 and descriptions of various agile models)

- **Customer Satisfaction:** Achieved through continuous delivery of valuable software and accommodating changes. (Principle 1, 2)
- **Adaptability to Change:** Agile processes are designed to welcome changing requirements, even late in development. (Principle 2)
- **Rapid Delivery:** Working software is delivered frequently (weeks rather than months). (Principle 3)
- **Collaboration:** Close, daily cooperation between business people and developers. (Principle 4)
- **Empowered Teams:** Projects are built around motivated individuals who are trusted. (Principle 5)
- **Technical Excellence:** Continuous attention to technical excellence and good design enhances agility. (Principle 8, 9)
- **Simplicity:** The art of maximizing the amount of work not done is essential. (Principle 10)
- **Improved Quality:** Continuous attention to testing and integration.

**Disadvantages of agile model (General):**
(Synthesized from common criticisms and textbook implications)

- **Scalability:** Can be challenging to implement for very large projects or distributed teams without significant adaptation.
- **Documentation:** Emphasis on working software over comprehensive documentation can sometimes lead to insufficient documentation. (Implied by Page 2-2 "focus on software itself rather than design and documentation")
- **Requirement for Skilled/Experienced Teams:** Self-organizing teams and practices like pair programming often require experienced and disciplined individuals.
- **Customer Availability:** Requires significant customer involvement and availability for feedback and clarification.
- **Unpredictability:** The iterative nature and flexibility can make long-term prediction of scope, cost, and schedule more difficult compared to plan-driven models.
- **Architectural Fragility:** Incremental development without a strong initial architectural vision can sometimes lead to issues.

---

### W24

#### (a)Why Software Engineering is also known as a Layered Technology? 03

(RE) See S24 Q1 (a).
(Refer to Chapter 1, Section 1.7, Pages 1-8 to 1-9)

#### (b)Explain Formal Technical Review (FTR). 04

(Refer to Chapter 7, Section 7.3.1, Pages 7-6 to 7-9)
"Formal Technical Review (FTR) sometimes called as walkthrough or an inspection is the most effective way of software review. This helps a lot for uncovering the software errors and to improve the quality of software." (Page 7-7)
"Formal Technical Review is a software quality assurance activity performed by software engineer." (Page 7-7)

**Objectives of FTR:**
(Refer to Page 7-7)

1. FTR is useful to uncover errors in logic, function and implementation for any representation of the software.
2. The purpose of FTR is to ensure that software meets specified requirements.
3. It also ensures that the software is represented according to predefined standards.
4. It helps to review the uniformity in software development process.
5. It makes the project more manageable.
   "Besides the above mentioned objectives, the purpose of FTR is to enable junior engineers to observe the analysis, design, coding and testing approaches more closely."

**The Review Meeting (FTR Process aspects):**
(Refer to Section 7.3.1.1, Page 7-8)
"Each FTR is conducted as a meeting and is considered successful only if it is properly planned, controlled and attended."
Constraints include:

- **Involvement of people:** Between 3 and 5 people.
- **Advance preparation:** At most 2 hours of work for each person.
- **Short duration:** Less than 2 hours for the meeting.
  "The review meeting is attended by the review leader, all reviewers and the producer."
  "The review leader is responsible for evaluating the product for its readiness."
  "The producer organizes a "walkthrough" the product, explaining the material, while the reviewers raise issues based on their advance preparation."
  "One of the reviewers becomes recorder who records all the important issues raised..."
  "At the end of the review, the attendees decide whether to accept the product or not, with or without modifications."

**Review Guidelines (for conducting FTRs):**
(Refer to Section 7.3.1.3, Page 7-9)

1. Concentrate on work product only.
2. Set an agenda of review and maintain it.
3. When certain issues are raised then debate or arguments should be limited.
4. Find out problem areas, but don't attempt to solve every problem noted.
5. Take written notes (it is for the recorder).
6. Limit the number of participants and insist upon advance preparation.
7. Develop a checklist for each product that is likely to be reviewed.
8. Allocate resources and time schedule for FTRs.
9. Conduct meaningful trainings for all reviewers.
10. Review earlier reviews which servers as the base.

#### (c)Define Coupling and Cohesion. Explain different types of Cohesion andits effects on software module. 07

**Coupling:**
(Refer to Chapter 5, Section 5.2.7.2, Page 5-8)
"Coupling effectively represents how the modules can be "connected" with other module or with the outside world."
"Coupling is a measure of interconnection among modules in a program structure."
"Coupling depends on the interface complexity between modules."
"The goal is to strive for lowest possible coupling among modules in software design."
"The property of good coupling is that it should reduce or avoid change impact and ripple effects."
Various types of coupling are listed as: Data coupling, Control coupling, Common coupling, Content coupling.

**Cohesion:**
(Refer to Chapter 5, Section 5.2.7.1, Page 5-7)
"With the help of cohesion the information hiding can be done."
"A cohesive module performs only "one task" in software procedure with little interaction with other modules. In other words cohesive module performs only one thing."
"The goal is to achieve high cohesion for modules in the system."

**Different types of Cohesion and its effects:**
(Refer to Chapter 5, Section 5.2.7.1, Page 5-7)

1. **Coincidentally cohesive:** "The modules in which the set of tasks are related with each other loosely then such modules are called coincidentally cohesive."
   - _Effect:_ Low cohesion, difficult to understand, maintain, and reuse. Changes to one task may unexpectedly affect others.
2. **Logically cohesive:** "A module that performs the tasks that are logically related with each other is called logically cohesive." (e.g., a module performing all I/O operations).
   - _Effect:_ Better than coincidental, but still can be complex as tasks might be quite different functionally, leading to tricky interfaces and maintenance.
3. **Temporal cohesion:** "The module in which the tasks need to be executed in some specific time span is called temporal cohesive." (e.g., initialization or shutdown modules).
   - _Effect:_ Tasks are related by timing. Can be acceptable if the tasks are also functionally related, otherwise can lead to modules with low cohesion.
4. **Procedural cohesion:** "When processing elements of a module are related with one another and must be executed in some specific order then such module is called procedural cohesive."
   - _Effect:_ Elements are related by their order of execution. Better than temporal if the sequence implies a functional relationship.
5. **Communicational cohesion:** "When the processing elements of a module share the data then such module is communicational cohesive." (e.g., all operations that access or update the same data record). \* _Effect:_ Good level of cohesion, as elements operate on the same data. Promotes data hiding.
   (Functional and Sequential cohesion are typically higher forms, though not explicitly detailed with definitions on this specific page, the aim for "one task" implies functional cohesion is the ideal.)
   **Effects of Cohesion (General):**
   High cohesion leads to modules that are easier to understand, test, maintain, and reuse. They are more robust as changes within a highly cohesive module are less likely to impact other modules. Low cohesion results in modules that are difficult to manage and prone to errors.

#### OR(c) Illustrate Requirement Engineering with suitable diagram. 07

(Refer to Chapter 4, Section 4.2, Page 4-4, Fig. 4.2.1 Requirement engineering tasks)
"Requirement engineering process performs following seven distinct functions:"
(The diagram Fig. 4.2.1 on Page 4-4 illustrates these tasks originating from "Requirement engineering tasks" and leading to "Requirement management").
The tasks/functions are:

1. **Inception:** (Refer to Section 4.2.1, Page 4-4) "The inception means specifying the beginning of the software project. Most of the software projects get started due to business requirements." Involves understanding the basic problem and identifying stakeholders.
2. **Elicitation:** (Refer to Section 4.2.2, Page 4-5) "Before the requirements can be analyzed and modelled they must undergo through the process of elicitation process. Requirements elicitation means requirements discovery." Involves gathering requirements from stakeholders.
3. **Elaboration:** (Refer to Section 4.2.3, Page 4-5) "Elaboration is an activity in which the information about the requirements is expanded and refined." Involves detailing and refining the elicited requirements.
4. **Negotiation:** (Refer to Section 4.2.4, Page 4-6) "Sometimes customer may demand for more than that is achieved or there are certain situations in which customer demands for something which cannot be achieved in limited business resources." Involves resolving conflicting requirements and agreeing on a final set.
5. **Specification:** (Refer to Section 4.2.5, Page 4-6) "A specification can be a written document, mathematical or graphical model, collection of use case scenarios or may be the prototypes." Involves documenting the agreed-upon requirements in a clear and unambiguous way (e.g., SRS).
6. **Validation:** (Refer to Section 4.2.6, Page 4-6) "Requirement Validation is an activity in which requirement specification is analyzed in order to ensure that the requirements are specified unambiguously." Involves checking that the specified requirements are correct, complete, and meet stakeholder needs.
7. **Requirement management:** (Refer to Section 4.2.7, Page 4-7) "Requirement management is the process of managing changing requirements during the requirements engineering process and system development." Involves managing changes to requirements throughout the project lifecycle.

The diagram (Fig. 4.2.1) shows "Requirement engineering tasks" branching into Inception, Elicitation, Elaboration, Negotiation, Specification, Validation, all feeding into "Requirement management".

---

Okay, I will continue writing out the answers for Question 3, referencing the provided textbook pages.

---

# Question 3

### S22

#### (a) What are the characteristics of good SRS document? 03

(Refer to Chapter 4, Section 4.16.1, Pages 4-84 to 4-85)
"Following are some characteristics of a good SRS -

1. **Correct:** The SRS must be correct. That means all the requirements must be correctly mentioned, or the requirements must be realistic by nature. For instance : While developing a word processing software, if there is a requirement for spell check facility and if software cannot find the spelling errors from the document, then that means requirement is incorrect.
2. **Complete:** To make the SRS complete, it should be specified what a software designer wants to create a software. The SRS is said to be complete only in following situations -
   - When SRS consists of all the requirements related to functionality, performance, attributes, design constraints or external interfaces.
   - When labels and corresponding references are mentioned for all the figures, diagrams and tables in the SRS.
   - When expected responses to the input data is mentioned by considering validity and invalidity of an input.
3. **Unambiguous:** When requirements are understood correctly then only unambiguous SRS can be written. Requirements are understood correctly then only one interpretation can be made from the specified requirements.
4. **Consistent:** If there are not conflicts in the specified requirements then SRS is said to be consistent.
5. **Logical or temporal conflict:** When one requirement specifies that event X should occur before event Y and if another requirement specifies that event Y should occur before event X.
6. **Characteristics of real-world object:** If one requirement suggests to make use of "radio button" and other specifies the "Check box button", then it represents conflicting characteristics.
7. **Two different descriptions about the same real world object:** If one requirement is specifying 'Enter' and other specifies 'submit' then it describes one and the same action.
8. **Stability:** In SRS, it is not possible to specify all the requirements. The SRS must contain all the essential requirements. Each requirement must be clear and explicit.
9. **Verifiable:** The SRS should be written in such a manner that the requirements that are specified within it must be satisfied by the software. For instance : "The GUI should look good". This requirement is not verifiable because one cannot specifically define "what is mean by good?".
10. **Traceable:** If origin of requirement is properly given or references of the requirements are correctly mentioned then such a requirement is called as traceable requirement.
    (Forward Traceability and Backward Traceability are also mentioned on Page 4-86).
11. **Modifiable:** (Though not explicitly listed as a numbered point on these pages, modifiability is a key characteristic often associated with a good SRS, meaning it should be easy to change if requirements evolve.)

#### (b) How the activity diagrams are useful in eliciting the requirements of software system? 04

(Refer to Chapter 4, Section 4.11.2 Activity Diagram, Pages 4-29 to 4-32)
"The activity diagram shows various activities performed, but it does not tell you who is responsible for these activities." (Swimlane diagrams, a type of activity diagram, address this - page 4-31).
Activity diagrams are useful in eliciting requirements because:

1. **Visualizing Workflow:** They provide a clear, graphical representation of the flow of activities in a system or a business process. This helps stakeholders, including non-technical users, to understand complex processes and workflows easily. (Implicit from the nature of diagrams like Fig. 4.11.5, Fig. 4.11.6)
2. **Identifying Steps and Decisions:** Activity diagrams clearly show sequential steps, parallel activities (forks and joins, Fig. 4.11.5, page 4-30), conditional logic (decision nodes), and iterations. This helps in breaking down complex operations into manageable parts and identifying all necessary actions and decision points required by the system.
3. **Clarifying Business Processes:** They can model existing business processes, which helps in understanding the "as-is" state before defining the "to-be" software system requirements. This ensures the software aligns with business needs.
4. **Defining Scope:** By visualizing the activities involved in a use case or a feature, activity diagrams help in defining the scope of what needs to be built and what is outside the scope.
5. **Facilitating Communication:** They serve as a communication tool between analysts, developers, and stakeholders, ensuring a shared understanding of how the system should behave. (Example 4.11.5, Page 4-32 shows an activity diagram for monitoring a sensor, which can be used for elicitation).
6. **Discovering Missing Steps or Scenarios:** While modeling the flow, analysts might discover missing steps, alternative paths, or exception handling scenarios that were not initially obvious, leading to more complete requirements.
7. **Detailing Use Cases:** Activity diagrams can be used to elaborate on the steps within a specific use case, providing more detail than a simple textual description.

#### (c) Compute function point value for a project with the following domain characteristics:

- No. of I/P = 30, No. of O/P = 62 , No. of user Inquiries = 24
- No. of files = 8 , No. of external interfaces = 2 . Assume that all the
- complexity adjustment values are average. 07

(Refer to Chapter 3, Section 3.2.2 Function Oriented Metrics, Pages 3-6 to 3-9. The method and an example are provided here. We will follow Example 3.2.1 on Page 3-8 as a template.)

**Step 1: Calculate Unadjusted Function Point (UFP)**
The weighting factors for "Average" complexity are (from table on Page 3-6):

- Number of user inputs (I/P): 4
- Number of user outputs (O/P): 5
- Number of user inquiries: 4
- Number of files: 10
- Number of external interfaces: 7

Given values:

- No. of I/P = 30
- No. of O/P = 62
- No. of user Inquiries = 24
- No. of files = 8
- No. of external interfaces = 2

UFP Calculation:

- Inputs: 30 \* 4 = 120
- Outputs: 62 \* 5 = 310
- Inquiries: 24 \* 4 = 96
- Files: 8 \* 10 = 80
- External Interfaces: 2 \* 7 = 14

Total UFP = 120 + 310 + 96 + 80 + 14 = **620**

**Step 2: Determine Complexity Adjustment Factor (CAF)**
The problem states "Assume that all the complexity adjustment values are average."
There are 14 Complexity Adjustment Factors (Fi) listed on Page 3-7. If "average" means each of the 14 factors has a rating of 2 (on a scale of 0-5 where 'Moderate' is often 2 or 3. The example on page 3-8 uses specific values for Fi, not an average assumption. Let's assume "average" means each of the 14 General System Characteristics (GSCs) has a rating of 2.5, which is the mid-point of the 0-5 scale. If "average" in the context of the example given on Page 3-8 implies a specific (Fi) value, we'd need that. The example 3.2.1 has (Fi) = 32. Let's assume "average" for this problem implies that the sum of the 14 GSCs (Fi) is such that the overall CAF calculation resembles the example, or we use a typical moderate value for each if individual ratings were expected.)

The formula for CAF is: CAF = [0.65 + 0.01 * (Fi)]
If we assume an "average" overall impact similar to Example 3.2.1 where (Fi) = 32:
CAF = [0.65 + 0.01 * 32]
CAF = [0.65 + 0.32]
CAF = **0.97**

Alternatively, if "average" means each of the 14 characteristics has a rating of 2 (out of 5, where 0=No influence, ..., 3=Average, ..., 5=Essential, as per the scale on Page 3-7), then (Fi) = 14 _ 2 = 28.
CAF = [0.65 + 0.01 _ 28] = [0.65 + 0.28] = 0.93

If "average" means each of the 14 characteristics has a rating of 3 (which is labeled "Average" on the scale on Page 3-7), then (Fi) = 14 _ 3 = 42.
CAF = [0.65 + 0.01 _ 42] = [0.65 + 0.42] = 1.07

Given the phrasing "all the complexity adjustment values are average," it's most likely referring to the individual GSC ratings. Let's use a rating of 3 for each of the 14 GSCs as "Average" is explicitly linked to a rating of 3 on the scale provided on page 3-7.
So, (Fi) = 14 _ 3 = 42.
CAF = 0.65 + (0.01 _ 42) = 0.65 + 0.42 = **1.07**

**Step 3: Calculate Function Point (FP)**
FP = UFP _ CAF
FP = 620 _ 1.07
FP = **663.4**

Therefore, the computed function point value is 663.4.

#### OR (a) Discuss the use of Data dictionaries in analysis modelling. 03

(Refer to Chapter 5, Section 5.6.1, sub-part (ii) Data Dictionaries, Page 5-20. Also, refer to Chapter 4, as data dictionaries are crucial for DFDs in analysis.)
"The data dictionary can be defined as an organized collection of all the data elements of the system with precise and rigorous definitions so that user and system analyst will have a common understanding of inputs, outputs, components of stores and intermediate calculations." (Page 5-20)

**Use of Data Dictionaries in Analysis Modelling:**

1. **Defining Data Elements:** Data dictionaries provide precise definitions for every data element used in the analysis models (like DFDs, ERDs). This includes data name, alias, where/how used, content description, and format. (Page 5-21 for notation). This ensures clarity and reduces ambiguity about data.
2. **Supporting DFDs:** When creating Data Flow Diagrams (DFDs), data dictionaries are essential to define the content of data flows, data stores, and the data processed by processes. Every data flow and data store in a DFD should have an entry in the data dictionary. (Implied by relationship of DFDs and Data Dictionaries, e.g. context of Fig. 4.14.22 and Data Dictionary example on Page 4-71).
3. **Ensuring Consistency:** By providing a centralized repository of data definitions, data dictionaries help ensure consistency across all analysis models and documentation. All analysts and stakeholders refer to the same definitions.
4. **Facilitating Communication:** They provide a common vocabulary for discussing data elements among the project team and with stakeholders, improving communication and understanding.
5. **Documenting Data Structures:** Data dictionaries document the composition of complex data structures, showing how elementary data items are grouped into larger structures. (Notation for composition on Page 5-21).
6. **Analysis of Data:** During analysis, studying the data dictionary can reveal redundancies, inconsistencies, or incompleteness in the data requirements.
7. **Basis for Design:** The detailed data definitions in the analysis-phase data dictionary serve as a crucial input for the data design and database design phases later in the development lifecycle.

#### OR (b) What are the tasks performed in requirement engineering? 04

(RE) See W24 Q2 OR (c) and S22 Q3 OR (c).
(Refer to Chapter 4, Section 4.2, Page 4-4, Fig. 4.2.1 Requirement engineering tasks)
The tasks (or distinct functions) performed in requirement engineering are:

1. **Inception:** Understanding the basic problem, purpose, and identifying stakeholders.
2. **Elicitation:** Discovering and gathering requirements from various sources, especially stakeholders.
3. **Elaboration:** Expanding on the elicited requirements, refining them, and adding detail.
4. **Negotiation:** Resolving conflicting requirements and prioritizing them to reach an agreement.
5. **Specification:** Formally documenting the agreed-upon requirements in a clear, unambiguous, and complete manner (e.g., in an SRS).
6. **Validation:** Ensuring that the specified requirements are correct, meet stakeholder needs, and are feasible.
7. **Requirement Management:** Managing changes to requirements throughout the software lifecycle.

#### OR (c) Discuss about COCOMO model for software estimation. 07

(RE) See S23 Q2 OR (c), S22 Q3 OR (c), S24 Q3 (c).
As noted previously, the provided OCR'd pages for Chapter 3 (Software Project Estimations) do not contain a detailed discussion of the COCOMO (Constructive Cost Model). The pages cover LOC-based, Function Point-based, Process-based, and Use-Case-based estimation.

If a discussion based _only_ on provided pages is required, the answer would state that while software estimation techniques are discussed, the specific COCOMO model is not detailed in these excerpts. One could then generally discuss the principles of software estimation found in Section 3.4 (Page 3-17 onwards), such as the need for sizing (LOC, FP), identifying factors influencing effort, and using historical data or expert judgment, and mention that COCOMO is one such algorithmic model that typically uses lines of code as a primary input and considers various cost drivers.

---

### S23

#### (a) List the characteristics of a good quality SRS. 03

(RE) See S22 Q3 (a).
(Refer to Chapter 4, Section 4.16.1, Pages 4-84 to 4-85)
Characteristics include: Correct, Complete, Unambiguous, Consistent, Verifiable, Modifiable, Traceable, Stable.

#### (b) Draw Data Flow Diagram for Library Management System 04

(Refer to Chapter 4, Section 4.14.2 Examples, Example 4.14.1 "DFD for library information system", Pages 4-60 to 4-62)
Fig. 4.14.6 Level 0 DFD (Context level DFD) on Page 4-61
Fig. 4.14.7 Level 1 DFD on Page 4-61
Fig. 4.14.8 Level 2 DFD on Page 4-62
(The question likely expects at least Level 0 and Level 1 DFDs.)

#### (c) Enlist and Explain Requirement Engineering Tasks in detail. 07

(RE) See W24 Q2 OR (c), S22 Q3 OR (c), S22 Q3 OR (b).
(Refer to Chapter 4, Section 4.2, Page 4-4 and subsequent sections 4.2.1 to 4.2.7 detailing each task from Pages 4-4 to 4-7.)
Tasks: Inception, Elicitation, Elaboration, Negotiation, Specification, Validation, Requirement Management. Each should be explained as per the textbook.

#### OR (a) Compare Coupling and Cohesion. 03

(Refer to Chapter 5, Section 5.2.7, Sr. No. table on Page 5-8 provides a direct comparison.)

| Sr. No. | Coupling                                                                                                | Cohesion                                                                                                                                      |
| :------ | :------------------------------------------------------------------------------------------------------ | :-------------------------------------------------------------------------------------------------------------------------------------------- |
| 1.      | Coupling represents how the modules are connected with other modules or with the outside world.         | In cohesion, the cohesive module performs only one thing.                                                                                     |
| 2.      | With coupling interface complexity is decided.                                                          | With cohesion, data hiding can be done.                                                                                                       |
| 3.      | The goal of coupling is to achieve lowest coupling.                                                     | The goal of cohesion is to achieve high cohesion.                                                                                             |
| 4.      | Various types of couplings are - Data coupling, Control coupling, Common coupling and Content coupling. | Various types of cohesion are - Coincidental cohesion, Logical cohesion, Temporal cohesion, Procedural cohesion and Communicational cohesion. |

#### OR (b) Draw Use Case Diagram for ATM System. 04

(Refer to Chapter 4, Section 4.5 Developing Use Cases, Example 4.5.2 "Use case diagram for ATM system", Page 4-16, Fig. 4.5.2 Use cases for ATM system)
The diagram on page 4-16 shows actors (Customer, Operator, Bank) and use cases (Withdrawal, Deposit, Inquiry, Establishes session, Shuts down system, Starts up system, Transaction).

#### OR (c) What is Risk Management? Explain RMMM plan 07

**What is Risk Management?:**
(Refer to Chapter 3, Section 3.7, Page 3-32)
"Definition of risk : The risk denotes the uncertainty that may occur in the choice due to past actions and risk is something which causes heavy losses."
"Definition of risk management : Risk management refers to the process of making decisions based on an evaluation of the factors that threats to the business."
Various activities for risk management are:

1. Risk identification
2. Risk projection
3. Risk refinement
4. Risk mitigation, monitoring and management.

**Explain RMMM plan:**
(Refer to Chapter 3, Section 3.12 Risk Plan, Page 3-40)
"The RMMM plan is a document in which all the risk analysis activities are described. Sometimes project manager includes this document as a part of overall project plan. Specific RMMM plan is not existed, however each risk can be described individually using risk information sheet. Typical template for RMMM plan or Risk information sheet can be:"
**Risk information sheet (Template for RMMM Plan components):**

- **Project name** `<enter name of the project for which risks can be identified>`
- **Risk Id** <#>
  - **Date** `<date at which risk is identified>`
  - **Probability** `<risk probability>`
  - **Impact** <low/medium/high>
- **Origin** `<the person who has identified the risk>`
  - **Assigned to** `<who is responsible for mitigating the risk>`
- **Description** `<description of risk identified>`
- **Refinement/Context** `<associated information for risk refinement>`
- **Mitigation/Monitoring** <enter the mitigation / monitoring steps taken>
- **Trigger/contingency plan** `<if risk mitigation fails then the plan for handling the risk>`
- **Status** `<running status that provides a history of what is being done for the risk and changes in the risk. Include the date the status entry was made>`
- **Approval** `<name and signature of person approving closure>`
  - **Closing date** `<date>`

"The risk information sheet can be maintained by database systems. After risk identification and analysis the entries are made in RMMM plan or Risk information sheet. The risk information sheet tracks all work performed to manage the risk. The risk information sheet is updated by the risk management team after every review. When risk is mitigated, the risk information sheet is closed." (This text is from page 3-40, though slightly rephrased and adapted from the context of risk table which is related). The general RMMM plan involves documenting how risks will be Mitigated, Monitored, and Managed.

---

### S24

#### (a) Describe software process metrics. 03

(Refer to Chapter 3, Section 3.1, Page 3-2, and Section 3.1.1, Page 3-2)
"Software Process and Project Metrics are Quantitative measures that enable Software engineers to gain insight into the efficacy of the Software Process and the Project." (Page 3-2)
"Process metrics are the set of process indicators that are used to improve the software processes. Process metrics is collected over the complete software life cycle. The software process can be improved with the help of process metrics. It can be illustrated as below:"
(Refer to Fig. 3.1.1 Process improvement on Page 3-2)
The process involves:

1. Measure specific attributes of the process
2. Develop set of meaningful metrics from these attributes
3. Using these attributes build a strategy for process improvement

"In making improvements to any software system, there are three basic quality factors to consider : product, people, and technology."
Process metrics help in understanding and improving the software development process itself, leading to better project outcomes, improved quality, and increased productivity. They can focus on aspects like defect removal efficiency, time taken for phases, adherence to schedule, etc.

#### (b) Explain extreme programming process. 04

(RE) See S22 Q2 OR (c).
(Refer to Chapter 2, Section 2.2.2 Process, Page 2-5, including Fig. 2.2.1 XP process)
Key aspects of the XP process:

- Customer specifies and prioritizes system requirements via story-cards.
- Developer team implements scenarios from story-cards.
- Work is broken down into small tasks.
- Software is released in small and frequent releases.
- New story-cards for new changes.
- Continuous evaluation with the customer.
- The process involves cycles of Planning, Design (simple design, refactoring), Coding (pair programming), and Testing (unit tests, integration tests).

#### (c) Write short note on COCOMO model. 07

(RE) See S23 Q2 OR (c), S22 Q3 OR (c), S24 Q3 (c).
As consistently noted, the provided OCR'd pages for Chapter 3 do not contain a detailed explanation or specific section on the COCOMO model.
A "short note" based _only_ on the provided material would have to state that:
Software project estimation is a critical activity (Section 3.4, Page 3-17). Various methods exist, such as those based on Lines of Code (LOC), Function Points (FP), process, and use cases, which are detailed in the chapter. The COCOMO model is another known algorithmic cost estimation model often used in software engineering, typically using LOC as a primary input and incorporating various cost drivers to adjust estimates for effort and duration. However, the specific formulas, types (Basic, Intermediate, Detailed), and application of cost drivers for COCOMO are not elaborated in these particular excerpts of the textbook.

#### OR (a) Write characteristics of good SRS. 03

(RE) See S22 Q3 (a) and S23 Q3 (a).
(Refer to Chapter 4, Section 4.16.1, Pages 4-84 to 4-85)

#### OR (b) Explain Earned value analysis in project scheduling 04

(The OCR'd TOC for Chapter 3 on Project Scheduling and Tracking (Section 3.6, Pages 3-27 onwards) does not explicitly list "Earned Value Analysis" or EVA as a subsection. This is a specific project management technique.)
If an answer must be constructed _only_ from provided pages:
Project scheduling involves estimating time and resources, arranging activities coherently, and continually updating schedules (Section 3.6.1, Page 3-27). Tracking the schedule involves comparing 'actual start date' and 'scheduled start date' and assessing progress quantitatively (Section 3.6.5, Tracking the Schedule, Page 3-31). Earned Value Analysis is a method used for such quantitative progress assessment. It integrates scope, schedule, and cost to measure project performance. Key metrics in EVA include Planned Value (PV), Earned Value (EV), and Actual Cost (AC), which are then used to calculate schedule variance (SV), cost variance (CV), and performance indices. While the detailed formulas and application of EVA are not explicitly described in these excerpts, its purpose aligns with the need to track project schedule and performance as mentioned.

#### OR (c) What is risk management? Describe RMMM plan. 07

(RE) See S23 Q3 OR (c) and W24 Q2 OR (c).
(Refer to Chapter 3, Section 3.7, Page 3-32 for Risk Management definition, and Section 3.12, Page 3-40 for RMMM Plan)

---

### W24

#### (a) Explain Function and Non-functional requirements using example. 03

(Refer to Chapter 4, Section 4.1, Page 4-2)
**Functional Requirements:**
"Functional requirements are the type of requirements that describe all the required functionality or system services. Functional requirements for library management system are:"
Examples (from text for library management):

- The user is able to search for the desired book or magzine
- The unique-id should be provided for every book.
- The user can download or print the required article for personal study.
  "Now functional requirements are the type of requirements that describe system properties and constraints." (This sentence seems to slightly conflate with non-functional; the prior examples are better for functional).
  Essentially, they define _what_ the system should do.

**Non-functional Requirements:**
"In short non functional requirements arise through: i) User needs ii) Budget constraints iii) Organizational policies iv) Safety regulations"
"Non functional requirements for library management system are:"
Examples (from text for library management):

- The user interface should respond within 20 seconds.
- The user interface should be according to some international standards.
- The user who wishes to read the article online must be authenticated first.
  Essentially, they define _how well_ the system should perform its functions, or constraints on the system.

#### (b) Explain RMMM. 04

(RE) See S23 Q3 OR (c), S24 Q3 OR (c), W24 Q2 OR (c).
RMMM stands for Risk Mitigation, Monitoring, and Management.
(Refer to Chapter 3, Section 3.12 Risk Plan, Page 3-40 for the RMMM Plan document structure)
The RMMM plan is a document that outlines how identified risks in a software project will be handled. It typically details:

- **Risk Mitigation:** Strategies and actions to be taken to reduce the probability or impact of each identified risk. (e.g., If "Staff turnover" is a risk, mitigation might be "Knowledge sharing sessions, documentation, cross-training").
- **Risk Monitoring:** How the identified risks will be tracked throughout the project. This includes defining triggers that would indicate a risk is becoming more probable or its impact is increasing. (e.g., Monitoring team morale for staff turnover risk).
- **Risk Management (Contingency Planning):** Actions to be taken if a risk actually materializes despite mitigation efforts. This is the plan B. (e.g., If staff turnover occurs, the contingency plan might involve hiring temporary staff or reallocating resources).
  The RMMM plan is often part of the overall project plan or a separate document, and it's a living document that is updated as new risks are identified or existing risk assessments change. The "Risk information sheet" described on page 3-40 is a key component for documenting and tracking individual risks within the RMMM framework.

#### (c) Illustrate Scrum with its advantages and disadvantages. 07

(RE) See S22 Q2 (c).
(Refer to Chapter 2, Section 2.3.3, Pages 2-11 to 2-12 for description, advantages, and disadvantages. Fig. 2.3.2 on Page 2-12 illustrates Scrum workflow activities.)

#### OR (a) Explain Gantt Chart w.r.t. project scheduling process. 03

(RE) See S23 Q2 (c) and S24 Q2 (b).
(Refer to Chapter 3, Section 3.6.1 Project Scheduling Process, Page 3-27, and Section 3.6.4 Time Line Chart (Gantt Chart), Pages 3-29 to 3-30)
The project scheduling process involves identifying activities, dependencies, estimating resources, assigning people, and then creating activity networks and bar charts (Section 3.6.1). The Gantt chart (or timeline chart) is one such bar chart used to visualize the project schedule (Section 3.6.4). It graphically depicts project tasks against a timeline, showing start dates, end dates, durations, and often dependencies and milestones. It helps in understanding the overall schedule, tracking progress, and managing the project timeline as part of the broader project scheduling process.

#### OR (b) Write a short note on Extreme Programming (XP). 04

(RE) See S22 Q2 OR (c) and S24 Q3 (b).
(Refer to Chapter 2, Section 2.2, Pages 2-4 to 2-8)
A short note on Extreme Programming (XP) would highlight:

- It's an agile process model suggested by Kent Beck.
- Key values: Communication, Simplicity, Feedback, Courage, Respect.
- Process involves small, frequent releases, customer involvement via story-cards, breaking work into small tasks.
- Core practices include: Paired programming, Test-Driven Development (TDD) / Unit testing (test-first), Continuous integration, Refactoring, Simple design, Collective code ownership, On-site customer.
- XP aims to deliver high-quality software quickly and adapt to changing requirements.

#### OR (c) Explain three golden rules for User Interface Design. 07

(Refer to Chapter 5, Section 5.7.2 Golden Rules, Page 5-30, and subsequent sections 5.7.2.1 to 5.7.2.3 on Pages 5-31 to 5-32 for detailed explanations of Thao Mandel's three golden rules.)

1. **Place the User in Control:** (Refer to Section 5.7.2.1, Page 5-31)
   - Define interaction modes to restrict unnecessary actions.
   - Make interaction flexible (e.g., mouse and keyboard).
   - Provide 'undo' or interruption facilities.
   - Allow user customization.
   - Hide technical details from the casual user.
   - Make on-screen objects interactive.
2. **Reduce the User's Memory Load:** (Refer to Section 5.7.2.2, Page 5-32)
   - Do not force the user to have short term memory (provide visual interface cues).
   - Establish meaningful defaults.
   - Use intuitive shortcuts (meaningful mnemonics).
   - The visual layout of the interface should be realistic.
   - Disclose information gradually (avoid information overload).
3. **Make the Interface Consistent:** (Refer to Section 5.7.2.3, Page 5-32)
   - The visual information (all screen layouts) should be consistent throughout and should be as per the design standards.
   - There should be limited set of input holding the non conflicting information.
   - The information flow transiting from one task to another should be consistent.
     (The text on page 5-33 under Mandel's principles also includes "Allow user to direct the current task into meaningful manner" and "Maintain consistency across family of product" which elaborate on control and consistency.)

---

# Question 4

### S22

#### (a) Describe golden rules of User Interface Design. 03

(RE) See W24 Q3 OR (c).
(Refer to Chapter 5, Section 5.7.2 Golden Rules, Page 5-30, and subsequent sections 5.7.2.1 to 5.7.2.3 on Pages 5-31 to 5-32 for detailed explanations of Thao Mandel's three golden rules.)

1. **Place the User in Control**
2. **Reduce the User's Memory Load**
3. **Make the Interface Consistent**

#### (b) What is the importance of software design? List out various design principles of good software design. 04

**Importance of software design:**
(Refer to Chapter 5, Section 5.1.1, Page 5-2)
"Software design is important to assess the quality of software. Because design is the only way that we can accurately translate the user requirements into the finished software product."
"Without design unstable system may get developed. Even if some small changes are made then those changes will go fail. It will become difficult to test the product. The quality of the software product can not be assessed until late in the software process."
A good design is the backbone that enables the creation of understandable, maintainable, and high-quality software that meets user needs effectively.

**Various design principles of good software design (Davis's principles):**
(Refer to Chapter 5, Section 5.3, Page 5-9)

1. The design process should not suffer from "tunnel vision".
2. The design should be traceable to the analysis model.
3. The design should not reinvent the wheel.
4. The design should "minimize the intellectual distance" between the software and the problem in the real world.
5. The design should exhibit uniformity and integration.
6. The design should be structured to accommodate change.
7. The design should be structured to degrade gently.
8. Design is not coding and coding is not design.
9. The design should be assessed for quality.
10. The design should be reviewed to minimize conceptual errors.

#### (c) What is testing? Explain the different levels of testing. 07

**What is testing?:**
(Refer to Chapter 6, Section 6.4, Page 6-9)
"Definition : Software testing is a critical element of software quality assurance and represents the ultimate review of specification, design and coding."
"The purpose of software testing is to ensure whether the software functions appear to be working according to specifications and performance requirements."
(Glen Myers' objectives of testing from Page 6-9: "1. Testing is a process of executing a program with the intend of finding an error. 2. A good test case is one that has high probability of finding an undiscovered error. 3. A successful test is one that uncovers an as-yet undiscovered error.")

**Different levels of testing (Testing Strategies):**
(Refer to Chapter 6, Section 6.5, Page 6-10. The strategies listed are typically considered levels of testing.)

1. **Unit testing:** (Refer to Section 6.5.1, Page 6-11) "In unit testing the individual components are tested independently to ensure their quality." "In this type of testing techniques are applied to detect the errors from each software component individually." Focus is on uncovering errors in design and implementation of individual modules/components. (Fig. 6.5.1 shows it at the 'Code' stage).
2. **Integration testing:** (Refer to Section 6.5.2, Page 6-12) "It focuses on issues associated with verification and program construction as components begin interacting with one another." "The objective is to take unit tested components and build a program structure that has been dictated by software design." This level tests the interfaces and interactions between integrated components.
3. **Validation testing:** (Refer to Section 6.5.3, Page 6-16) "The integrated software is tested based on requirements to ensure that the desired product is obtained." "It provides assurance that the software validation criteria (established during requirements analysis) meets all functional, behavioural and performance requirements." This ensures the software meets the customer's requirements. Acceptance testing (Alpha/Beta) is a key part of this. (Fig. 6.5.1 shows it related to 'Requirements').
4. **System testing:** (Refer to Section 6.5.4, Page 6-17) "In system testing all system elements forming the system is tested as a whole." This level tests the complete, integrated system to verify that it meets all specified requirements. It includes recovery, security, stress, and performance testing. (Fig. 6.5.1 shows it at the 'System engineering' stage).

#### OR (a) What is DevOps? 03

(Refer to Chapter 9, Section 9.1 Overview, Page 9-2, and Section 9.6 What is DevOps?, Page 9-6)
"DevOps encourages the development, IT operations, quality engineering and security activities to be performed in coordination and collaboration to produce better, more reliable products." (Page 9-2)
"DevOps is a culture which promotes collaboration between Development and Operations Team to deploy code to production faster in an automated and repeatable way." (Page 9-2)
"Definition : Devops is a practice in which development and operation engineers participate together in entire lifecycle activities of system development from design, implementation to product support. The term Devops is derived from "Software DEVelopment " and "information technology OPerationS"." (Page 9-6)

#### OR (b) What is architectural design? Enlist different style and patterns of architecture. 04

**What is architectural design?:**
(Refer to Chapter 5, Section 5.5 Architectural Design, Page 5-13)
"The goal of architectural design is to establish the overall structure of software system. Architectural design represents the link between design specification and actual design process."
"Software Architecture is a structure of systems which consists of various components, externally visible properties of these components and the inter-relationship among these components."
(Also refer to Chapter 5, Section 5.4.2 Architectural Design Element, Page 5-11: "The architectural design gives the layout for overall view of the software.")

**Different styles and patterns of architecture:**
(Refer to Chapter 5, Section 5.5.2 Architectural Style, Page 5-14)
"The commonly used architectural styles are:

1. Data centered architectures.
2. Data flow architectures.
3. Call and return architectures.
4. Object oriented architectures.
5. Layered architectures."

#### OR (c) Discuss the concepts of Cohesion and Coupling in detail. 07

(RE) See W24 Q2 (c) and S23 Q3 OR (a).
(Refer to Chapter 5, Section 5.2.7.1 Cohesion, Page 5-7, and Section 5.2.7.2 Coupling, Page 5-8. Detail the definitions and types of each as provided in the textbook.)

---

### S23

#### (a) Describe golden rules of User Interface Design. 03

(RE) See S22 Q4 (a) and W24 Q3 OR (c).
(Refer to Chapter 5, Section 5.7.2 Golden Rules, Page 5-30, and subsequent sections 5.7.2.1 to 5.7.2.3 on Pages 5-31 to 5-32.)

#### (b) What is BVA? List out guidelines of BVA. 04

(Refer to Chapter 6, Section 6.8.2 Boundary Value Analysis (BVA), Page 6-31)
**What is BVA?:**
"Boundary value analysis is done to check boundary conditions."
"A boundary value analysis is a testing technique in which the elements at the edge of the domain are selected and tested."
"Using boundary value analysis, instead of focusing on input conditions only, the test cases from output domain are also derived."
"Boundary value analysis is a test case design technique that complements equivalence partitioning technique."

**Guidelines of BVA:**
(Refer to Page 6-31)

1. "If the input condition specified the range bounded by values x and y, then test cases should be designed with values x and y. Also test cases should be with the values above and below x and y."
2. "If input condition specifies the number of values then the test cases should be designed with minimum and maximum values as well as with the values that are just above and below the maximum and minimum should be tested."
3. "If the output condition specified the range bounded by values x and y, then test cases should be designed with values x and y. Also test cases should be with the values above and below x and y."
4. "If output condition specifies the number of values then the test cases should be designed with minimum and maximum values as well as with the values that are just above and below the maximum and minimum should be tested."
5. "If the internal program data structures specify such boundaries then the test cases must be designed such that the values at the boundaries of data structure can be tested."

#### (c) What is Software testing? Compare: Black box testing and White Box testing 07

**What is Software testing?:**
(RE) See S22 Q4 (c).
(Refer to Chapter 6, Section 6.4 Introduction to Software Testing, Page 6-9)

**Compare: Black box testing and White Box testing:**
(Refer to Chapter 6, Section 6.9 Comparison between Black Box and White Box Testing, Page 6-34. A table provides a direct comparison.)

| Sr. No. | Black box testing                                                                                                               | White box testing                                                                                                          |
| :------ | :------------------------------------------------------------------------------------------------------------------------------ | :------------------------------------------------------------------------------------------------------------------------- |
| 1.      | Black box testing is called behavioural testing.                                                                                | White box testing is called glass box testing.                                                                             |
| 2.      | Black box testing examines some fundamental aspect of the system with no regard for internal logical structure of the software. | In white box testing the procedural details, all the logical paths, all the internal data structures are closely examined. |
| 3.      | During black box testing the program cannot be tested 100 percent.                                                              | White box testing lead to test the program thoroughly.                                                                     |
| 4.      | This type of testing is suitable for large projects.                                                                            | This type of testing is suitable for small projects.                                                                       |

#### OR (a) Give the difference between Validation and Verification. 03

(The provided textbook TOC does not have an explicit "Validation vs. Verification" section. However, the concepts are fundamental and can be inferred.)
**Verification:** (Focuses on "Are we building the product right?")
It is the process of evaluating software to determine whether the products of a given development phase satisfy the conditions imposed at the start of that phase. It often involves reviews, inspections, and walkthroughs of documents, code, and design.
(Refer to Chapter 7, Quality Control on page 7-3 is preventive, aligning with verification: "This is an activity with the primary goal as to prevent the defects.")

**Validation:** (Focuses on "Are we building the right product?")
It is the process of evaluating software during or at the end of the development process to determine whether it satisfies specified requirements. It involves actual testing of the software.
(Refer to Chapter 6, Section 6.5.3 Validation Testing, Page 6-16: "The integrated software is tested based on requirements to ensure that the desired product is obtained.")
(Refer to Chapter 7, Quality Assurance on page 7-3 involves identifying and correcting defects, aligning with validation: "This is an activity with the primary goal as to identify and correct the defects.")

**Differences (summarized):**

- **Purpose:** Verification checks if the software conforms to its specification (building it right). Validation checks if the software meets user needs (building the right thing).
- **Timing:** Verification is often done throughout the lifecycle on intermediate work products. Validation is typically done on the executable software, often at the end of phases or the project.
- **Activities:** Verification includes reviews, inspections. Validation includes testing.

#### OR (b) What is Cyclomatic Complexity? Define steps to find cyclomatic complexity using flow graph. 04

**What is Cyclomatic Complexity?:**
(Refer to Chapter 6, Page 6-22, under Step 2: Calculate the cyclomatic complexity)
Cyclomatic complexity is a software metric used to indicate the complexity of a program. It is a quantitative measure of the number of linearly independent paths through a program's source code. It can be computed in three ways:

1. Cyclomatic complexity = Total number of regions in the flow graph (+1 if the graph is strongly connected, though textbooks often use the number of bounded regions).
2. Cyclomatic complexity = E - N + 2 (where E is the number of edges, N is the number of nodes in the flow graph).
3. Cyclomatic complexity = P + 1 (where P is the number of predicate (decision making) nodes).

**Define steps to find cyclomatic complexity using flow graph:**

1. **Step 1: Design the flow graph for the program or a component.** (Refer to Chapter 6, Section 6.7.1.1 Flow Graph Notation, Page 6-20 and Page 6-22) This involves representing procedural statements as nodes and control flow as edges.
2. **Step 2: Calculate the cyclomatic complexity.** (Refer to Page 6-22) Choose one of the three methods mentioned above (Regions, E-N+2, or P+1) and apply it to the constructed flow graph.

#### OR (c) Explain the importance of Software Quality Assurance. Also explain different CMM levels. 07

**Importance of Software Quality Assurance (SQA):**
(Refer to Chapter 7, Section 7.2 Software Quality Assurance (SQA), Page 7-5)
"We have already discussed the definition of software quality... says that quality is the conformance to functional and non functional requirements of the product."
"There are three main reasons for why software quality gets failed ?"

1. Software requirements must be well understood.
2. Similar to explicit requirements it is also essential to understand the implicit requirements.
3. The set of development criteria has to be decided.
   "Software quality assurance is the process in which conformance to the requirements of the product is made."
   SQA is important because it:

- Provides confidence that the software product will meet its quality goals.
- Helps in preventing defects by establishing processes and standards.
- Identifies and helps in correcting defects early in the lifecycle.
- Ensures that the development process itself is of high quality.
- Manages and improves the overall quality of the software throughout its lifecycle.
  (SQA Activities on page 7-5 include: Create SQA plan, Participate in description of software process, Review software engineering activities, Authenticate software work products, Ensure deviations are documented, Identify noncompliance.)

**Different CMM levels:**
(Refer to Chapter 7, Section 7.5.2 CMM, Page 7-14)
"The Capability Maturity Model (CMM) is used in assessing how well an organization's processes allow to complete and manage new software projects."
"Various process maturity levels are:

- **Level 1: Initial** - Few processes are defined and individual efforts are taken. The software process is characterized as ad hoc, and occasionally even chaotic.
- **Level 2: Repeatable** - To track cost schedule and functionality basic project management processes are established. Basic project management processes are established to track cost, schedule, and functionality.
- **Level 3: Defined** - The process is standardized, documented and followed. All the projects use documented and approved version of software process which is useful in developing and supporting software. The software process for both management and engineering activities is documented, standardized, and integrated into an organization-wide software process.
- **Level 4: Managed** - Both the software process and product are quantitatively understood and controlled using detailed measures. Detailed measures of the software process and product quality are collected.
- **Level 5: Optimizing** - Establish mechanisms to plan and implement change. Innovative ideas and technologies can be tested. Continuous process improvement is enabled by quantitative feedback from the process and from piloting innovative ideas and technologies."

---

### S24

#### (a) Compare black box testing and white box testing. 03

(RE) See S23 Q4 (c).
(Refer to Chapter 6, Section 6.9 Comparison between Black Box and White Box Testing, Page 6-34)

#### (b) Write characteristics of good user interface. 04

(Refer to Chapter 5, Section 5.7.1 User Interface Design Principles, Page 5-30. These principles describe characteristics of a good UI.)

1. **User familiarity:** "Instead of using computer terminology make use of user oriented terminologies."
2. **Consistency:** "The appropriate level of consistency should be maintained in the user interface. For example the commands or menus should be of same format."
3. **Minimal surprise:** "The commands should operate in a known way. This makes user to easily predict the interface."
4. **Recoverability:** "The system should provide recovering facility to user from his errors so that user can correct those error. For example an undo command should be given..."
5. **User guidance:** "The user interface can be effectively used by a novice user if some user guidance such as help systems, online manuals etc. are supplied."
   (Other characteristics implied by "Golden Rules" on Pages 5-31, 5-32: user is in control, reduced memory load for user, consistent.)

#### (c) Explain details that should be incorporated in SRS. 07

(Refer to Chapter 4, Section 4.16 Software Requirements Specification (SRS), starting from Page 4-80. The standard IEEE STD 830-1998 outline on Pages 4-81 to 4-83 provides the details.)
Major sections and details to be incorporated:

1. **Introduction** (Page 4-81)
   - Purpose of this document
   - Scope of this document
   - Definitions, Acronyms, Abbreviations (Page 4-82, 11.1)
   - References (Page 4-82, 11.2)
   - Overview (Page 4-82, 1.3)
2. **General Description** (Page 4-82)
   - Product perspective
   - Product functions
   - User characteristics
   - General constraints
   - Assumptions and dependencies
3. **Specific Requirements (Functional Requirements)** (Page 4-82)
   - Detailed description of each function, inputs, processing, outputs.
   - Often organized by feature, use case, or mode of operation.
4. **External Interface Requirements** (Page 4-83)
   - User Interfaces (4.1)
   - Hardware Interfaces (4.2)
   - Software Interfaces (4.3)
   - Communications Interfaces (4.4)
5. **Performance Requirements** (Page 4-83, 5.0)
   - Specifies speed and memory requirements, response times, throughput etc.
6. **Design Constraints** (Page 4-83, 6.0)
   - Specifies any constraints for the design team such as software or hardware limitations, standards compliance.
7. **Other Non Functional Attributes** (Page 4-83, 7.0)
   - Security (7.1)
   - Binary Compatibility (7.2)
   - Reliability (7.3)
   - Maintainability (7.4)
   - Portability (7.5)
   - Extensibility (7.6)
   - Reusability (7.7)
   - Application Compatibility (7.8)
   - Resource Utilization (7.9)
   - Serviceability (7.10)
8. **Operational Scenarios** (Page 4-84, 8.0)
9. **Preliminary Schedule** (Page 4-84, 9.0)
10. **Preliminary Budget** (Page 4-84, 10.0)
11. **Appendices** (Page 4-82, 11.0)

#### OR (a) Differentiate alpha testing and beta testing. 03

(Refer to Chapter 6, Section 6.5.3.1 Acceptance Testing, Page 6-17, "Difference between Alpha and Beta Testing" table.)

| Alpha testing                                                                                                  | Beta testing                                                                                                |
| :------------------------------------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------- |
| This testing is done by a developer or by a customer under the supervision of developer in company's premises. | This testing is done by the customer without any interference of developer and is done at customer's place. |
| Sometime full product is not tested using alpha testing and only core functionalities are tested.              | The complete product is tested under this testing. Such product is usually given as free trial version.     |

#### OR (b) Describe phases of requirement engineering process. 04

(RE) See S22 Q3 OR (b), S23 Q3 (c), W24 Q2 OR (c).
(Refer to Chapter 4, Section 4.2 Requirement Engineering Task, Page 4-4, Fig. 4.2.1. The tasks listed are the phases: Inception, Elicitation, Elaboration, Negotiation, Specification, Validation, Requirement Management.)

#### OR (c) List out different architectural styles in software design and describe any one style in detail. 07

(RE) See S22 Q4 OR (b).
**List of different architectural styles:**
(Refer to Chapter 5, Section 5.5.2 Architectural Style, Page 5-14)

1. Data centered architectures.
2. Data flow architectures.
3. Call and return architectures.
4. Object oriented architectures.
5. Layered architectures.

**Description of one style in detail (e.g., Data Centered Architectures):**
(Refer to Chapter 5, Section 5.5.2.1 Data Centered Architectures, Page 5-15, Fig. 5.5.3)
"Data centered architecture posses the property of interchangeability. Interchangeability means any component from the architecture can be replaced by a new component without affecting the working of other components."
"In data centered architecture the data can be passed among the components."
"In data centered architecture,

- Components are : Database elements such as tables, queries.
- Communication are : By relationships
- Constraints are : Client software has to request central data store for information."
  (Fig. 5.5.3 shows a central Data store with multiple Client software components interacting with it.) This style is common in database-heavy applications where the central data repository is the primary means of communication and coordination among components.

---

### W24

#### (a) Differentiate Object Oriented Design and Procedural Design. 03

(Refer to Chapter 5, Section 5.6.1 Function Oriented Design (Procedural), Page 5-20, and Section 5.6.2 Object Oriented Design, Page 5-25. A direct comparison table is also provided on Page 5-25.)

| Structured analysis (Procedural)                                                                                                                            | Object oriented analysis                                                                                                                             |
| :---------------------------------------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------- |
| The structured analysis is a method in which focus is on functionality of the system.                                                                       | The object oriented analysis is a technique in which main emphasis is on objects. Each object is a combination of data members and member functions. |
| The Data Flow Diagrams(DFD),Control Flow Diagrams(CFD) and Entity Relationship Diagrams(ERD) can be drawn in structured analysis.                           | The use cases, class diagram, sequence diagram, state chart diagram, activity diagram, component diagrams can be drawn in this method.               |
| This is a simple technique of system analysis.                                                                                                              | In this technique, the overhead of partitioning the structure into modules is involved.                                                              |
| Finding bugs is difficult because focus of this approach is merely on functionalities. That means the system structure is according to the functionalities. | Finding bugs is simple because system structure is modular.                                                                                          |

#### (b) Explain at least four Software Reliability Metrics. 04

(Refer to Chapter 7, Section 7.4 Software Reliability, Page 7-9, and Section 7.4.1 Measure of Reliability and Availability, Page 7-10)

1. **MTBF (Mean Time Between Failure):** "MTBF : mean-time-between-failure is a simple measure of software reliability which can be calculated as MTBF = MTTF + MTTR where MTTF means mean-time-to-failure and MTTR stands for mean-time-to-repair." (Page 7-10). It indicates the average time the system operates without a failure.
2. **Availability:** "Availability : It's another measure of software reliability software availability is defined as the probability that the program is working according to the requirements at a given points in time. It is measured as Availability = (MTTF/(MTTF+MTTR))\* 100 %" (Page 7-10). It measures the percentage of time the system is operational and available for use.
3. **Defect Density (Implied):** While not explicitly named as a metric here, the concept of tracking defects ("defects/KLOC or defects/FP" mentioned on page 7-10 as less useful than MTBF by some researchers) is a common reliability-related metric. It measures the number of defects per unit size of software.
4. **Failure Rate (Implied):** The inverse of MTBF can be considered a failure rate. Also, discussions around the "idealized curve" vs "actual curve" for software failure rate (Chapter 1, Fig 1.4.1, Page 1-4) relate to this concept, indicating how often failures occur over time.
   (The textbook on these specific pages primarily details MTBF and Availability.)

#### (c) Write a short note on CMM levels with suitable diagram. 07

(RE) See S23 Q4 OR (c).
(Refer to Chapter 7, Section 7.5.2 CMM, Page 7-14 for the levels. A diagram showing the progression of levels from 1 to 5 would be suitable. The textbook itself does not provide a diagram for CMM levels on this page, but the levels are clearly listed.)
**CMM Levels:**

- **Level 1: Initial:** Processes are ad hoc, chaotic. Success depends on individual effort.
- **Level 2: Repeatable:** Basic project management processes are established to track cost, schedule, and functionality. Success can be repeated for similar projects.
- **Level 3: Defined:** Software process is documented, standardized, and integrated into an organization-wide software process.
- **Level 4: Managed:** Detailed measures of the software process and product quality are collected. Both software process and products are quantitatively understood and controlled.
- **Level 5: Optimizing:** Continuous process improvement is enabled by quantitative feedback and from piloting innovative ideas and technologies.
  (A suitable diagram would be a staircase or a tiered pyramid showing Level 1 at the bottom and Level 5 at the top.)

#### OR (a) Define Stub and Driver w.r.t. Unit Testing. 03

(Refer to Chapter 6, Section 6.5.1 Unit Testing, Point 6 on Page 6-12, and Fig. 6.5.3 Unit testing environment)
"Drivers and stub software need to be developed to test incomplete software."

- **Driver:** "The "driver" is a program that accepts the test data and prints the relevant results." It is a "dummy" module that calls the module being tested (the module under test - MUT). It simulates the calling environment for the MUT.
- **Stub:** "And the "stub" is a subprogram that uses the module interfaces and performs the minimal data manipulation if required." It is a "dummy" module called by the module being tested. It simulates the behavior of modules that are called by the MUT but are not yet developed or integrated.
  (Fig. 6.5.3 on Page 6-12 illustrates how a Driver calls a Module, which in turn might call Stubs.)

#### OR (b) Explain Version Control and Change Control. 04

**Version Control:**
(Refer to Chapter 8, Section 8.7.3 Version Control, Page 8-13, Fig. 8.7.2)
"Version is an instance of a system which is functionally distinct in some way from other system instances."
"Version control works to help manage different versions of configuration items during the development process."
"The configuration management allows a user to specify the alternative configurations of the software system by selecting appropriate version."
"Certain attributes are associated with each software version. These attributes are useful in identifying the version. For example: The attribute can be 'date', 'creator', 'customer', 'status'."
"In practice the version needs an associated name for easy reference."
"Different versions of a system can be shown by an evolution graph as Each version of software system is a collection of software configuration items." (Fig. 8.7.2 shows version numbering in an evolution graph).

**Change Control:**
(Refer to Chapter 8, Section 8.7.2 Change Control, Pages 8-11 to 8-12, Fig. 8.7.1)
"Changes in any software projects are vital."
"For a large software engineering project, uncontrolled change creates lot of chaos. For managing such changes, human procedures or automated tools can be used."
The change control process (Refer to Fig. 8.7.1):

- **Step 1:** Need for the change arises.
- **Step 2:** Change request is submitted by the user.
- **Step 3:** Developers evaluate the request (technical merits, side effects, impact).
- **Step 4:** Change report is generated and presented to Change Control Authority (CCA).
- **Step 5:** CCA makes a final decision on status/priority.
- **Step 6:** Engineering Change Order (ECO) is generated if approved.
- **Step 7:** Object to be changed is checked out.
- **Step 8:** Changes are made, SQA activities applied.
- **Step 9:** Changed object is checked in, new version created.
  "The checked in and checked out mechanisms require two important elements - Access control, Synchronization control."

#### OR (c) What is McCabes Cyclomatic Complexity? Explain various steps to find Cyclomatic Complexity using flow graph. 07

(RE) See S23 Q4 OR (b).
McCabe's Cyclomatic Complexity is a software metric that provides a quantitative measure of the logical complexity of a program.
(Refer to Chapter 6, Page 6-22, under Step 2 for calculation methods. The "various steps" involve first creating the flow graph as per Section 6.7.1.1, Page 6-20.)
**Steps:**

1. **Construct the Flow Graph:** Represent the program's control flow graphically. Nodes represent processing blocks or decision points, and edges represent the transfer of control. (Refer to Fig. 6.7.1 Notations on Page 6-21 for common flow graph elements like sequence, if-else, while, case).
2. **Calculate Cyclomatic Complexity (V(G)) using one of the following methods:**
   _ **Using Regions:** V(G) = Number of bounded regions in the flow graph + 1 (if the graph is considered to start and end at a single point conceptually, or simply the number of bounded regions if only internal complexity is measured as per some definitions. The textbook does not explicitly state "+1" for regions here, but it's a common way to include the outer unbounded region or ensure correspondence with other methods). The textbook on page 6-23 states "Cyclomatic complexity = Regions encountered = 3" for an example, implying it's the count of enclosed areas.
   _ **Using Edges and Nodes:** V(G) = E - N + 2, where E is the number of edges (arcs) in the flow graph and N is the number of nodes. (Page 6-22) \* **Using Predicate Nodes:** V(G) = P + 1, where P is the number of predicate nodes (nodes that contain a condition, like 'if', 'while' which have more than one exit path). (Page 6-22)
   The value of V(G) provides an upper bound for the number of test cases required to achieve branch coverage.

---

# Question 5

### S22

#### (a) Explain Formal Technical Review. 03

(RE) See W24 Q2 (b) and S23 Q5 OR (b).
(Refer to Chapter 7, Section 7.3.1 Formal Technical Reviews (FTR), Pages 7-6 to 7-9)

#### (b) Compare white box and black box testing. 04

(RE) See S23 Q4 (c) and S24 Q4 (a).
(Refer to Chapter 6, Section 6.9 Comparison between Black Box and White Box Testing, Page 6-34)

#### (c) Discuss five-level of SEI-CMM 07

(RE) See S23 Q4 OR (c) and W24 Q4 (c).
(Refer to Chapter 7, Section 7.5.2 CMM, Page 7-14)

#### OR (a) What is software quality? 03

(Refer to Chapter 7, Section 7.1 Quality Concepts, and Subsection 7.1.1 Quality, Page 7-2)
"There are many definitions of software quality. In simple words, the software quality means 'how well the software works'."
"Software quality can be defined as "the conformance to explicitly stated functional and performance requirements, explicitly documented development standards and implicit characteristics that are expected of all professionally developed software"."
"Quality of design is the characteristics of the item which is specified for the designer."
"Quality of conformance is the degree to which the design specifications are followed during manufacturing."
"Along with quality of design and quality of conformance, customer's satisfaction is very important factor in any software product."

#### OR (b) What is software maintenance? Describe different types of maintenance. 04

**What is software maintenance?:**
(Refer to Chapter 8, Section 8.1 Software Maintenance, Page 8-2)
"Software maintenance is an activity in which program is modified after it has been put into use."
"In software maintenance usually it is not preferred to apply major software changes to system's architecture."
"Maintenance is a process in which changes are implemented by either modifying the existing system's architecture or by adding new components to the system."

**Describe different types of maintenance:**
(Refer to Chapter 8, Section 8.1.2 Types of Software Maintenance, Page 8-2)

1. **Corrective maintenance:** "Means the maintenance for correcting the software faults."
2. **Adaptive maintenance:** "Means maintenance for adapting the change in environment (different computers or different operating systems)."
3. **Perfective maintenance:** "Means modifying or enhancing the system to meet the new requirements."
4. **Preventive maintenance:** "Means changes made to improve future maintainability."

#### OR (c) Briefly explain software configuration management 07

(Refer to Chapter 8, Section 8.5 Introduction to Software Configuration Management (SCM), Pages 8-9 to 8-14)
**Definition:** (Page 8-9) "Software configuration management is a set of activities carried out for identifying, organizing and controlling changes throughout the lifecycle of computer software."
**Need for SCM:** (Section 8.5.1, Page 8-9) "The software configuration management is concerned with managing the changes in the evolving software. If the changes are not controlled at all then this stream of uncontrolled change can cause the well-running software project into chaos." Essential activities include: Identify changes, Control changes, Ensure changes are properly implemented, Report changes.
**SCM Process (Primary Objectives):** (Section 8.7, Page 8-10)

1. **Configuration Identification:** "Identify the items that define the software configuration." This involves identifying Software Configuration Items (SCIs - see Section 8.6, Page 8-10) such as source programs, executable programs, documents, data. Object identification is key (Section 8.7.1, Pages 8-10 to 8-11).
2. **Change Control:** "Manage changes to one or more items." This involves a formal process for requesting, evaluating, approving/rejecting, and implementing changes. (Section 8.7.2, Pages 8-11 to 8-12, Fig. 8.7.1 Change control process).
3. **Version Control:** "Facilitate to create different versions of the application." Manages multiple versions of SCIs as they evolve. (Section 8.7.3, Page 8-13, Fig. 8.7.2 Version numbering).
4. **Configuration Authentication (Audit):** "To ensure that the quality of the software is maintained as the configuration evolves over the time." Verifies that SCIs are correct and that changes have been properly implemented. (Section 8.7.4, Page 8-13).
5. **Status Reporting:** (Section 8.7.5, Page 8-14) "The status reporting focuses on communication of changes to all people in an organization that involve with changes." Tracks the status of SCIs and changes.

SCM is crucial for maintaining the integrity and traceability of software throughout its lifecycle, especially in projects with evolving requirements and multiple developers.

---

### S23

#### (a) Describe CASE building blocks. 03

(Refer to Chapter 10, Section 10.4.1 Building Blocks of CASE, Page 10-8, Fig. 10.4.1 Building block for CASE Tools)
"The CASE tools may exist as a single tools or a collection of multiple tools. These tools must communicate with various elements such as hardware, database, people, network, operating system and so on. This communication creates an integrated environment."
"Fig. 10.4.1 represents the building block for CASE. The bottom most layer consists of environment architecture and hardware platform. The environment architecture consists of collection of system software and human work pattern that is applied during the software engineering process."
"A set of probability services connects the CASE tools with the integration framework."
"The integration framework is a collection of specialized programs which allows the CASE tools to communicate with the database and to create same look and feel for the end-user."
"At the top of this building block a collection of CASE tools exist."
The building blocks shown in Fig. 10.4.1 are (from bottom up):

1. Environment Architecture (Hardware Platform)
2. Operating System
3. Probability Services (linking to Integration Environment)
4. Integration Environment
5. Case Tools

(Refer to Chapter 10, Section 10.4.2 Integrated CASE Environment, Page 10-12, Fig. 10.4.2 for a different model of integrated CASE environment layers):

1. Shared Repository Layer (CASE database, Access control functions)
2. Object Management Layer (Integration services, configuration management services)
3. Tool Management Layer (Various CASE Tools)
4. User Interface Layer (Interface tool kit, Presentation Protocol)

The question likely refers to the first model described (Fig 10.4.1).

#### (b) Write short note on Reverse Engineering. 04

(Refer to Chapter 8, Section 8.3 Reverse Engineering, Pages 8-4 to 8-6)
"Reverse engineering is the process of design recovery. In reverse engineering the data, architectural and procedural information is extracted from a source code." (Page 8-4)
**Important issues in reverse engineering:** (Page 8-5)

1. **Abstraction level:** "This level helps in obtaining the design information from the source code." High abstraction level helps understand the program.
2. **Completeness level:** "The completeness means detailing of abstract level." Decreases as abstraction level increases. Interactivity helps here.
3. **Directionality level:** "Directionality means extracting the information from source code and give it to software engineer." Can be one-way or two-way (where source code is fed to a re-engineering tool).

**Reverse Engineering Process:** (Section 8.3.1, Page 8-5, Fig. 8.3.1)

1. Take dirty source code or unstructured source code.
2. Restructure code (to make it clean).
3. Extract abstractions (evaluate older programs for procedures, interfaces, data structures, databases).
4. Initial documentation.
5. Refine and simplify.
6. Final specification (clear, unambiguous final specification obtained from unstructured source code).
   The process aims to improve understandability of existing software systems, often as a precursor to re-engineering or maintenance.

#### (c) List and explain the challenges in DevOps Implementation. 07

(Refer to Chapter 9, Section 9.12 Challenges with DevOps Implementation, Page 9-13)

1. **Cultural change:** "Any organization must promote the collaborative culture for effective implementation of DevOps. The leaders should bring transparency in the work process. There must be positive atmosphere in an organization." Resistance to changing established ways of working.
2. **Bringing silos and sectors together:** "There is a tendency of maintaining silos and sectors within the team... Due to this practice, there lies a big gap between teams. Both Dev and Ops work in silos, leading to a lack of transparency and poor teamwork." Breaking down barriers between development, operations, QA, and security teams.
3. **Giving up legacy systems:** "Organizations must give up the old or outdated systems and must adopt modern and efficient systems. Handling new systems along with the old existing systems in the organization can be challenging many times."
4. **Tool selection confusion:** "There are number of tools available in the market which tempt the DevOp developers to choose different tools. This leads to changing and updating the tools frequently... the team should adopt well organized long term strategy to use specific tool." Selecting and integrating the right set of tools from a vast and evolving landscape.
5. **Different metrics:** "During product development process each team measure their performance using different metrics. When the projects is to be implemented using DevOps technology, there must be a common metric to be used to measure the performance. Accepting a common measure of performance is sometimes challenging for different teams." Aligning on common metrics that reflect overall value delivery.
6. **Resistance to change:** "The teams are normally unwilling to accept the changes. They are resistance to change their preferred working style. They do not open up the silos to other teams. This makes it difficult to other teams to work and may create an unhealthy environment." Overcoming inertia and fear of the unknown.
7. **Process challenges:** "DevOps strategy does not define specific rules to implement the process or to use the tools. The only restriction is to follow the project goal. Although this gives lot of flexibility and chances to use innovative methodologies, it may lead to challenging situations like confusion and disputes among the team members of some strategies." Defining and standardizing new processes while maintaining flexibility.

#### OR (a) Explain Version and Change Control Management. 03

(RE) See W24 Q4 OR (b).
**Version Control:** (Refer to Chapter 8, Section 8.7.3, Page 8-13)
**Change Control:** (Refer to Chapter 8, Section 8.7.2, Page 8-11)
(Summarize key aspects of both as per textbook descriptions)

#### OR (b) Explain Formal Technical Review. 04

(RE) See S22 Q5 (a) and W24 Q2 (b).
(Refer to Chapter 7, Section 7.3.1 Formal Technical Reviews (FTR), Pages 7-6 to 7-9)

#### OR (c) Explain Software Re-Engineering process model. 07

(Refer to Chapter 8, Section 8.2 Re-Engineering, Page 8-3, Fig. 8.2.1 Re-engineering process activities)
"Software re-engineering means re-structuring or re-writing part or all of the software engineering system."
"The software re-engineering is needed for the applications which require frequent maintenance."
**Advantages of software re-engineering:**

1. **Reduced risk:** "The re-engineering allows the developer to eliminate certain constraints on the system. This helps in reducing the risks of failures."
2. **Reduced cost:** "The cost of re-engineering is often significantly less than the costs of developing new software."

**Re-engineering process activities (from Fig. 8.2.1):**

1. **Source program** (input)
2. **Source code translation:** (Page 8-4) "In this phase the code is converted to a new language."
3. **Reverse engineering:** (Page 8-4) "Under this activity the program is analysed and understood thoroughly." This leads to Program documentation.
4. **Program structure improvement:** (Page 8-4) "Restructure automatically for understandability."
5. **Program modularization:** (Page 8-4) "The program structure is reorganized." This leads to a Modularized program.
6. **Data re-engineering:** (Page 8-4) "Finally clean-up and restructure system data." This processes Original data and can lead to Re-engineered data.
   The outputs are a **Structured program** and **Re-engineered data**. The overall process takes a source program and original data, and through a series of analysis, restructuring, and transformation steps, produces an improved (re-engineered) system.

---

### S24

#### (a) Write a short note on formal technical reviews. 03

(RE) See S22 Q5 (a), S23 Q5 OR (b), W24 Q2 (b).
(Refer to Chapter 7, Section 7.3.1 Formal Technical Reviews (FTR), Pages 7-6 to 7-9. A short note would summarize its purpose, objectives, and key aspects of the review meeting.)

#### (b) Explain importance of SQA (Software Quality Assurance). 04

(RE) See S23 Q4 OR (c).
(Refer to Chapter 7, Section 7.2 Software Quality Assurance (SQA), Page 7-5)

#### (c) Describe different types of maintenance in software engineering. 07

(RE) See S22 Q5 OR (b).
(Refer to Chapter 8, Section 8.1.2 Types of Software Maintenance, Page 8-2. Describe Corrective, Adaptive, Perfective, and Preventive maintenance as per the textbook.)

#### OR (a) Compare verification with validation. 03

(RE) See S23 Q4 OR (a).
(Refer to inferred differences from Chapter 6 and 7, or standard SE definitions.)

#### OR (b) What are the advantages and disadvantages of component based development model? 04

**Component Based Development Model (also CBSE - Component Based Software Engineering):**
(Refer to Chapter 10, Section 10.1 Component Based Software Engineering (CBSE), Page 10-2)
**Advantages (Benefits):**

1. "By CBSE, it becomes easy to construct understandable and maintainable software."
2. "Components are independent entities and they do not interfere in other component's operation."
3. "Component implementation is hidden."
4. "Communication among the components is through well defined interfaces."
5. "Component platform can be shared and ultimately it reduces the cost of development."
   (Additional advantages generally include faster development, increased reusability, improved quality due to pre-tested components.)

**Disadvantages (Drawbacks):**

1. "It is difficult to verify the trustworthiness of the component without source code."
2. "The quality of component can not be verified."
3. "It is not possible to predict the emergent properties of component compositions."
4. "It is difficult to make the trade-offs between the features of various components."
   (Additional disadvantages can include reliance on third-party vendors, integration challenges, cost of components, and managing component versions.)
   (Also refer to Chapter 1, Section 1.12 Component Based Development, Page 1-27: "These components have specialized targeted functionalities and well defined interfaces. Hence it is easy to integrate these components into the existing software." This points to an advantage. "The component based development model makes use of various characteristics of spiral model. This model is evolutionary in nature.")

#### OR (c) Describe phases of DevOps lifecycle. 07

(Refer to Chapter 9, Section 9.9 The 7 C's of DevOps Lifecycle for Business Agility, Page 9-9)
The 7Cs of DevOps represent the phases/aspects of its lifecycle:

1. **Continuous business planning:** "During this phase the planning for identifying skills, resources required and outcome is made."
2. **Continuous development:** "In this phase, development sketch plan is prepared and programming techniques are identified. Before continuous integration, development teams would write a bunch of code for three to four months. Then those teams would merge their code in order to release it."
3. **Continuous integration:** "Continuous integration is the practice of quickly integrating newly developed code with the main body of code that is to be released. Continuous integration saves a lot of time when the team is ready to release the code." Involves checking code in, compiling, and basic validation testing.
4. **Continuous deployment:** "It is the practice of deploying all the way into production without any human intervention. Teams that utilize continuous delivery don't deploy untested code; instead, newly created code runs through automated testing before it gets pushed out to production."
5. **Continuous testing (CT):** "Continuous testing (CT) is the process of executing automated test cases as part of the software delivery pipeline. Its goal is to obtain immediate and continuous feedback on the business risks associated with a software release candidate."
6. **Continuous delivery and monitoring:** "With continuous delivery, every code change is built, tested, and then pushed to a non-production testing or staging environment... Continuous monitoring is a process of monitoring the applicaton continuously to check its service, performance and security."
7. **Continuous feedback:** "This is a process which allows for an immediate response from your customers for your product and its features and helps you modify accordingly."

---

### W24

#### (a) Compare Verification and Validation. 03

(RE) See S23 Q4 OR (a) and S24 Q5 OR (a).
(Refer to inferred differences from Chapter 6 and 7, or standard SE definitions.)

#### (b) Explain the core benefits of DevOps. 04

(Refer to Chapter 9, Section 9.7 DevOps Importance and Benefits, Page 9-6, under "Benefits")
"Various benefits of Devops are -

- **Technical benefits**
  1. Continuous software delivery is possible
  2. There is less complexity to manage the project.
  3. The problems in the project gets resolved faster.
- **Cultural benefits**
  1. The productivity of teams get increased.
  2. There is higher employee engagement.
  3. There arise greater professional development opportunities.
- **Business benefits**
  1. The faster delivery of the product is possible.
  2. The operating environment becomes stable.
  3. The communication and collaboration gets improved among the teams members and customer.
  4. More time is available for innovation rather than fixing and maintaining."

#### (c) Explain any Two Black Box Testing Methods with suitable example. 07

(Refer to Chapter 6, Section 6.8 Black-Box Testing, Pages 6-29 onwards)
Choose any two from:

1. **Equivalence Partitioning:** (Section 6.8.1, Page 6-30, Fig. 6.8.1)

   - **Explanation:** "It is a black box technique that divides the input domain into classes of data. From this data test cases can be derived." "An ideal test case uncovers a class of errors that might require many arbitrary test cases to be executed before a general error is observed." Equivalence classes represent sets of valid or invalid states for input conditions.
   - **Guidelines:** If input is a range, one valid and two invalid classes. If a specific value, one valid and two invalid. If a member of a set, one valid and one invalid. If Boolean, one valid and one invalid.
   - **Example:** For an input field accepting integers from 1 to 100:
     - Valid equivalence class: Any integer between 1 and 100 (e.g., 50).
     - Invalid equivalence class 1: Any integer < 1 (e.g., 0, -5).
     - Invalid equivalence class 2: Any integer > 100 (e.g., 101, 200).
     - Test cases would pick one value from each class.
2. **Boundary Value Analysis (BVA):** (Section 6.8.2, Page 6-31)

   - **Explanation:** "A boundary value analysis is a testing technique in which the elements at the edge of the domain are selected and tested." It complements equivalence partitioning by focusing on boundary values, where errors often occur.
   - **Guidelines:** Test values at the boundaries, just above, and just below the boundaries for both input and output conditions.
   - **Example:** (From text, page 6-31) For an integer D with input condition [-2, 10]:
     - Test values: -2, 10 (boundaries); -1, 0 (just above/at lower valid boundary); 11 (just above upper boundary); -3 (just below lower boundary). The example explicitly lists: -2, 10, 11, -1, 0. (Note: -1 and 0 are within the valid range if -2 is the lower bound, so values tested are min, max, min+1, max-1, min-1, max+1 for the range).
3. **Graph based Testing:** (Section 6.8.3, Page 6-32, Fig. 6.8.2)

   - **Explanation:** "In the graph based testing, a graph of objects present in the system is created. The graph is basically a collection of nodes and links. Each node represents the object that is participating in the software system and links represent the relationship among these objects." Node weight represents object properties, link weight represents relationship characteristics. Important objects and their relationships are tested.
   - **Example:** For a web application, nodes could be web pages and links could be navigation paths. Test cases would be designed to traverse specific paths in the graph.
4. **Orthogonal Array Testing:** (Section 6.8.4, Page 6-32)

   - **Explanation:** "Orthogonal array testing is a kind of testing method which can be applied to the applications in which input domain is relatively small but there could be large number of test cases." It helps reduce the number of test cases by testing pair-wise combinations of input values systematically, useful when exhaustive testing of all combinations is impractical. It uses predefined orthogonal arrays (e.g., L9) to select test cases.
   - **Example:** (From text, Pages 6-32, 6-33) An application with three sections (top, bottom, middle) each having a Boolean variable (true/false). Exhaustive testing is 2^3 = 8 cases. Using an L9 orthogonal array might reduce this to 4 or 5 carefully selected test cases while still covering all pair-wise interactions. The textbook example uses an L9 array to map three factors, each with two levels (true/false), resulting in specific test case combinations.

#### OR (a) Explain Client/Server Software Engineering. 03

(Refer to Chapter 10, Section 10.2 Client Server Software Engineering, Pages 10-4 to 10-5)
"The client-server architecture models the application in such a way that the server consists of a set of services which are demanded by the clients. That means clients demand for the services and servers provide these services to the clients. The clients and servers are the separate processes." (Page 10-4, Fig. 10.2.1 Client/server architecture).
**Two Tier Architecture:** (Section 10.2.1, Page 10-4)
"In client-server architecture, one server might be connected more than one client. The simplest client-server architecture is called two-tier client server architecture in which the application executes on two layers - client layer and server layer."

- **Thin client model:** Data management and application logic on server; client runs presentation. (Example: Compiler application).
- **Fat client model:** Server for data management only; application logic and presentation on client. (Example: ATM system, Fig. 10.2.2).
  **Three Tier Architecture:** (Section 10.2.2, Page 10-5, Fig. 10.2.3)
  "In this architecture, the presentation, application processing and data management are logically separate processes and execute on different processors." Tiers are Presentation, Application, and Data management. (Example: Internet banking).

#### OR (b) Differentiate between Reverse Engineering and Forward Engineering. 04

(Refer to Chapter 8, Section 8.3 Reverse Engineering, Page 8-4; Section 8.4 Forward Engineering, Page 8-6. The difference is explicitly stated on Page 8-7.)
"**Difference between Forward and Reverse Engineering**

- Forward engineering is a process of constructing a system for specific purpose.
- Reverse engineering is a process of de-constructing a system in order to extend the functionalities or in order to understand the working of the system."
  (Table on Page 8-6 also compares Software Engineering [akin to Forward] with Reverse Engineering):

| Software engineering                                                                                              | Reverse engineering                                                                                                                                                                        |
| :---------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| The software engineering is conducted using, requirement gathering, analysis, design, implementation and testing. | The reverse engineering is conducted using restructuring the code, cleaning it, by extracting the abstractions. After refinement and simplification of the final code the code gets ready. |
| It is simple and straightforward approach.                                                                        | It is complex because cleaning the dirty or unstructured code requires more efforts.                                                                                                       |
| Documentation or specification of the product is useful to the end-user.                                          | Documentation or specification of the product is useful to the developer.                                                                                                                  |

#### OR (c) Explain COCOMO Model for project estimation. 07

(RE) See S23 Q2 OR (c), S22 Q3 OR (c), S24 Q3 (c), W24 Q3 (c).
As consistently noted, the provided OCR'd pages for Chapter 3 do not contain a detailed explanation of the COCOMO model. An answer based _only_ on these pages would have to state this limitation and discuss general estimation principles from Section 3.4 if allowed.

---
